# 在java中==和equals()的区别  
==是直接比较的两个对象的堆内存地址，如果相等，则说明这两个引用实际是指向同一个对象地址的。对于基本数据类型
（byte，short，char，int，float，double，long，boolean）来说，他们是作为常量在方法区中的常量池里面以HashSet
策略存储起来的，对于这样的字符串 "123" 也是相同的道理，在常量池中，一个常量只会对应一个地址，因此不管是再多
的 123,"123" 这样的数据都只会存储一个地址，所以所有他们的引用都是指向的同一块地址，因此基本数据类型和String
常量是可以直接通过==来直接比较的。  
另外，对于基本数据的包装类型（Byte, Short, Character，Integer，Float, Double，Long,  Boolean）除了Float和
Double之外，其他的六种都是实现了常量池的，因此对于这些数据类型而言，一般我们也可以直接通过==来判断是否相等。
Integer 在常量池中的存储范围为[-128,127]。
  
在Object类型的equals方法是直接通过==来比较的，和==是没有任何区别的。但equals方法是可以由我们自己重写的。  
  
# String类  
采用了共享模式；  
String类被final关键字修饰，不能被继承；  
String pools是为了提高JAVA内存利用率而采用的措施，当遇到String a = “HELLO”时，JAVA会先在字符串池中查找是否存
在“HELLO”这个字符串，如果没有，则新创建一个对象，然后变量a指向这个地址，然后再遇到String b = “HELLO”时，由于
字符串池中以及有了“HELLO”这个对象，所以直接将变量b的地址指向“HELLO”，省去了重新分配的麻烦；
使用new操作创建的字符串对象不指向字符串池中的对象，会先为变量开辟空间，然后将值写入空间。
intern()方法的原理：如果池中已经有相同的 字符串。有则直接返回池中的字符串，否则先将字符串添加到池中，再返回。
````
public static void main(String[] args) {
	String a = "HELLO";
	String b = "HELLO";
	String c = new String("HELLO");
	String d = new String("HELLO");
	System.out.println(a == b); //true 这里true，字符池的效果体现出来了
	System.out.println(b == c); //false
	System.out.println(c == d); //false
	System.out.println(a.equals(b)); //true equals都会返回true

	//intern()方法试用一把
	c = c.intern();
	System.out.println(b == c); //true 这里直接也返回true了
}
````

# String类不可变性的好处
1.只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串
变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：String interning是
指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。)，因为这样的话，如果变量改变了它的值，那么其它指
向这个值的变量的值也会一起改变。  
2.如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库
的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，
否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。  
3.因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使
用同步。字符串自己便是线程安全的。  
4.类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被
改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。  
5.因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的
键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。

# String, StringBuffer, StringBuilder区别  
String是字符串常量，而StringBuffer和StringBuilder是字符串变量。由String创建的字符内容是不可改变的，而由
StringBuffer和StringBuidler创建的字符内容是可以改变的。  
String类中定义的char数组是final的；而StringBuffer和StringBuilder都是继承自AbstractStringBuilder类，它们的内部
实现都是靠这个父类完成的，而这个父类中定义的char数组只是一个普通是私有变量，可以用append追加。  
StringBuffer是线程安全的，而StringBuilder是非线程安全的。StringBuilder是从JDK 5开始，为StringBuffer类补
充的一个单线程的等价类。我们在使用时应优先考虑使用StringBuilder，因为它支持StringBuffer的所有操作，但是
因为它不执行同步，不会有线程安全带来额外的系统消耗，所以速度更快。

# 基本类型中的缓冲池? 什么时候使用缓冲池的数据?
Java虚拟机为了优化8中基本数据类型的包装对象，为他们提供了缓冲池，缓冲池的大小为一个字节。（8个bit位，长度为2^8
位，范围是-128~127）。超过缓冲池的范围，包装类对象就自己在缓冲池外面赋值。如果对象的值在缓冲池范围内，就指向缓
冲池的值，缓冲池里面的值是共享的。

# java中的null类型
java语言中有两种类型，一种是基本类型，还有一种是引用类型。  
1. 首先，null是java中的关键字，像public、static、final。它是大小写敏感的，你不能将null写成Null或NULL，编译器
将不能识别他们然后报错。
2. 就像每种原始类型都有默认值一样，int默认值为0，boolean的默认值为false，null是任何引用类型的默认值，不严格的说
是所有object类型的默认值。就像你创建了一个布尔类型的变量，它将false作为自己的默认值，java中的任何引用变量都将null
作为默认值。这对所有变量都是适用的，如成员变量、局部变量、实例变量、静态变量(但当你使用一个没有初始化的局部变量，
编译器会警告你)。
3. 要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转
化成任何类型。
4. null可以赋值给引用变量，不能将null赋值给基本类型变量，如int、double、float、boolean。
5. 任何含有null值的包装类在java拆箱生成基本数据类型时候都会抛出一个空指针异常。
6. 如果使用了带有null值的引用类型的变量，instanceof操作会返回false  
7. 可以使用静态方法来使用一个值为null的引用类型变量。因为静态方法使用静态类型绑定，不会抛空指针异常
9 可以将null传递给方法使用，这时方法可以接收任何引用类型，如 public void print(Object obj) 可以这样调用print(null).
编译可以通过，但结果就取决去你的方法了。这个例子中的print方法，不会抛出空指针异常，只是退出，业务逻辑允许的话，
推荐使用null安全的方法。
10. 可以使用== 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作，如大于、小于。与SQL不同，java中的null==null
会返回true；

# switch…case语句
case 标签可以是 ：
* 类型为 char、byte、short 或 int 的常量表达式。
* 枚举常量。
* 从 Java SE 7 开始，case 标签还可以是字符串字面量。

# Object有哪些方法
1. clone方法
保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。
2. getClass方法
final方法，获得运行时类型。
3. toString方法
该方法用得比较多，一般子类都有覆盖。返回一个能代表该类型的字符串。
4. finalize方法
该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
5. equals方法
该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。
6. hashCode方法
该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。
一般必须满足obj1.equals(obj2)==true。可以推出obj1.hashCode()==obj2.hashCode()，但是hashCode相等不一定就满足equals。
不过为了提高效率，应该尽量使上面两个条件接近等价。
7. wait方法
wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获
得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
调用该方法后当前线程进入睡眠状态，直到以下事件发生。
（1）其他线程调用了该对象的notify方法。
（2）其他线程调用了该对象的notifyAll方法。
（3）其他线程调用了interrupt中断该线程。
（4）时间间隔到了。
此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。
8. notify方法
该方法唤醒在该对象上等待的某个线程。
9. notifyAll方法
该方法唤醒在该对象上等待的所有线程。

# lambda表达式

# 抽象，封装，继承，多态
* 抽象:将相同的类的共同特征总结出来，构造成类的过程。包括数据抽
象以及行为抽象。数据抽象变成类的成员变量，行为抽象变成类
的成员函数。抽象只关心成员变量以及成员函数，并不关系具体的实现细节。  
* 继承是从已有的类得到继承信息创建新的类的过程，继承可以表示
为 is-a 关系 。比如动物就是父类或者说基类。那么动物有很多种，
比如小狗，小猫，它们有很多共同的属性，它们都是动物。那么表现
在代码里就是，它们可以直接把行为或者数据继承过来。  
* 封装其实可以理解为：“装”与“封”，就是把数据以及操作方法封
装在函数里/类，然后再装起来。也就是把数据以及操作数据的方法绑定
起来，对外界提供已经定义好的接口进行访问。面向对象的本质就是将
现实世界描绘成一系列的完全自治，封闭的对象。可以理解为我们
无论内部实现有多复杂，使用者可以完全不用理，只需要知道怎么使
用就可以了。
* 多态可以大概分为两种方式：方法重载与方法重写。  
方法重载（Overload）:编译时的多态性（也就是前绑定），方法可
以根据不同参数类型进行不同的调用，方法名字一致。  
方法重写（Override）:运行时的多态（也称为后绑定）。要实现方法
重写需要做：1.方法重写，也就是子类继承父类并重写了父类已经
有的方法。 2.用父类型引用来引用子类型对象，这样可以实现调用
同样的方法会根据子类对象的不同表示出不一样的行为。

# a += b 与 a = a + b有什么区别
先运算后赋值可能会有类型转换问题；

# 怎样将byte数组转换为string
1. 通过String类将String转换成byte[]或者byte[]转换成String；
2. 通过Base64 将String转换成byte[]或者byte[]转换成String[Java 8]

# 一些代码
````
byte a1 = 1, a2 = 2;
final byte b1 = 2, b2 = 3;
a1 = b1 + b2;  	// 不会报错
a1 = a1 + a2;	// 会报错

````  
````
String s1 = "abc";
String s2 = new String(s1);
s1 == s2;		// false
s1.equals(s2);	// true
````  
````
String s1 = "abc";
String s2 = "a" + new String("bc");
String s3 = "a" + "bc";
s1 == s2;	// false
s1 == s3;  // true
````  

# 基本数据类型转换 
byte、short、char运算会转换为Int；  
如操作数之一为double，则另一个操作数先被转化为double，再参与算术运算。   
类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。  
如采用+=、*=等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型。  
当运算符为自动递增运算符（++）或自动递减运算符（--）时，如果操作数为byte，short或char类型不发生改变；  

# 引用类型间转换
子类能直接转换为父类 或 接口类型；  
父类转换为子类要 强制类型转换；且在运行时若实际不是对应的对象，会抛出ClassCastException运行时异常；  

# java标识符
由英文字母或数字组成的；英文字母是大写的A-Z，小写的是a-z，以及“_”和“$”；数字包括0-9；其他的符号是不
能用在标识符里的。不能用Java所保留的关键字。在Java里标识符是大小写敏感的。  

# 字节流和字符流又有什么区别
1. 字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串，字节流提供了处理任何类型
的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以；
2. 字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操
作字节和字节数组。
3. 字节流也称为原始数据，需要用户读入后进行相应的编码转换。而字符流的实现是基于自动转换的，读取数据时
会把数据按照JVM的默认编码自动转换成字符。  
字符流主要为了国际化，支持UNICODE；

# 读写文件实例
````
//递归输出给定字符串下文件目录
public void printFile(String dirStr) {
	printFile(null,dirStr,"");
}
public void printFile(File parent,String dirStr,String strPre) {
	File f1=new File(parent,dirStr);
	if(!f1.isDirectory()) {
		System.out.println("文件："+strPre+f1.getName());
		return ;
	}
	System.out.println("目录："+strPre+f1.getName());
	strPre=strPre+"++";
	for(String fileStr:f1.list()) {
		printFile(f1,fileStr,strPre);
	}
}
````  
````
/*
 * 读取指定文件
 */
public void readFile(String filePath) {
	File file=new File(filePath);
	try {
		FileInputStream in=new FileInputStream(file);
		BufferedReader reader=
				new BufferedReader(new InputStreamReader(in, "utf-8"));
		String s;
		while ((s=reader.readLine())!=null) {
			System.out.println(s);
		}
		reader.close();
	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
````  
````
/*
 * 向指定文件写内容
 */
public void writeFile(String filePath) {
	File file=new File(filePath);
	try {
		FileOutputStream out=new FileOutputStream(file);
		BufferedWriter writer=
				new BufferedWriter(new OutputStreamWriter(out, "utf-8"));
		for(int i=0;i<5000;i++) {
			writer.write(i+"   :"+"some 新东西");
			writer.newLine();
		}
		writer.flush();
		writer.close();
	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
````  
````
/*
 * 利用nio读文件
 */
public void nioRead(String filePath) {
	File file=new File(filePath);
	ByteBuffer buffer=ByteBuffer.allocate(1024);
	try {
		FileChannel in=new FileInputStream(file).getChannel();
		int i;
		while((i=in.read(buffer))!=-1) {
			buffer.flip();
			System.out.print(Charset.forName("utf-8").decode(buffer));
			buffer.clear();
		}
		in.close();
	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
````  
````
/*
 * 利用nio写文件
 */
public void nioWrite(String filePath) {
	File file=new File(filePath);
	ByteBuffer buffer=ByteBuffer.allocate(1024);
	try {
		FileChannel out=new FileOutputStream(file).getChannel();
		for(int i=0;i<5000;i++) {
			buffer.put("测c123s试\r\n".getBytes("utf-8"));
			buffer.flip();
			out.write(buffer, out.size());
			buffer.clear();
		}
		out.close();
	} catch (FileNotFoundException e) {
		e.printStackTrace();
	} catch (IOException e) {
		e.printStackTrace();
	}
} 
````  

# 先继承后实现

# 类之间的关系
* 依赖（ dependence ), 即“ uses-a” 关系， 是一种最明显的、 最常见的关系。例如， Order类使用
 Account 类是因为 Order 对象需要访问 Account 对象查看信用状态。但是 Item 类不依赖于 Account 
 类， 这是因为 Item 对象与客户账户无关。因此， 如果一个类的方法操纵另一个类的对象，我们就说
 一个类依赖于另一个类。应该尽可能地将相互依赖的类减至最少。
* 聚合（aggregation ), 即“ has-a” 关系， 是一种具体且易于理解的关系。 例如， 一个Order 对象
 包含一些 Item 对象。聚合关系意味着类 A 的对象包含类 B 的对象。
* 继承（ inheritance ), 即“ is-a” 关系， 是一种用于表示特殊与一般关系的。

# JRE判断程序是否执行结束的标准是什么
所有用户线程执行完毕；不包括守护线程；

# JDBC使用什么设计模式?
jdbc规范使用到主要涉及的设计模式：桥接模式；  
桥接模式的作用：在“类的功能层次结构”与“类的实现层次结构”之间建立桥梁；  
类的功能层次结构：1，父类中具有基本功能；2，在子类中增加新的功能；    
类的实现层次结构：1，父类通过声明抽象方法来定义接口；2，子类通过实现具体方法来实现接口；  
![桥接模式](./markdownFile/桥接模式.png)  
上图中类的功能层次结构：Abstraction，RefinedAbstraction;类的实现层次结构:
Implementor,ConcreteImplementor;桥梁为Abstraction持有的impl；  

# 解释一下驱动在JDBC中的角色
DriverManager就是其中的Abstraction，java.sql.Driver
是 Implementor，com.mysql.jdbc.Driver是Implementor的一个具体实现；

# JDBC执行大致流程
1， 加载JDBC驱动程序；
````
Class.forName("com.mysql.jdbc.Driver") ;
````  
2， 提供JDBC连接的URL，用户名，密码
````
String url = "jdbc:mysql://localhost:3306/test" ; 
````  
3， 创建数据库的连接
````
try{ 
Connection con = DriverManager.getConnection(url , username , password ) ; 
}catch(SQLException se){ 
System.out.println("数据库连接失败！"); 
se.printStackTrace() ; 
}
````  
4， 创建一个Statement
Statement实例分为以下 3 种类型：  
1、执行静态SQL语句。通常通过Statement实例实现。  
2、执行动态SQL语句。通常通过PreparedStatement实例实现。  
3、执行数据库存储过程。通常通过CallableStatement实例实现。
````
Statement stmt = con.createStatement() ; 
PreparedStatement pstmt = con.prepareStatement(sql) ; 
CallableStatement cstmt = con.prepareCall("{CALL demoSp(? , ?)}") ;
````  
5， 执行SQL语句  
Statement接口提供了三种执行SQL语句的方法：executeQuery 
、executeUpdate 和 execute  
1、ResultSet executeQuery(String sqlString)：执行查询数据库的SQL
语句 ，返回一个结果集（ResultSet）对象。  
2、int executeUpdate(String sqlString)：用于执行INSERT、UPDATE
或 DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等  
3、execute(sqlString):用于执行返回多个结果集、多个更新计数或二者
组合的语句。  
````  
ResultSet rs = stmt.executeQuery("SELECT * FROM ...") ; 
int rows = stmt.executeUpdate("INSERT INTO ...") ; 
boolean flag = stmt.execute(String sql) ;
````  
6， 处理结果  
两种情况：  
1、执行更新返回的是本次操作影响到的记录数。  
2、执行查询返回的结果是一个ResultSet对象。  
````
while(rs.next()){ 
　　String name = rs.getString("name") ; 
　　String pass = rs.getString(1) ; // 此方法比较高效 
}
````  
7， 关闭JDBC对象  
操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序
和声明顺序相反：  
1、关闭记录集  
2、关闭声明  
3、关闭连接对象  
````
if(rs != null){ // 关闭记录集 
　　try{ 
        rs.close() ; 
　　}catch(SQLException e){ 
　　　　e.printStackTrace() ; 
　　} 
} 
if(stmt != null){ // 关闭声明 
　　try{ 
　　　　stmt.close() ; 
　　}catch(SQLException e){ 
　　　　e.printStackTrace() ; 
　　} 
} 
if(conn != null){ // 关闭连接对象 
　　try{ 
　　　　conn.close() ; 
　　}catch(SQLException e){ 
　　　　e.printStackTrace() ; 
　　} 
}
````  

# 一般关系型和对象数据模型之间的对应关系
* 每个持久对象映射一张表;每个持久对象必须有一个主键;
* 持久对象之间的关系用外键关联
* 持久对象要有内聚性，无关的内容拿出去，单独创建持久对象

# JDK, JRE, JVM的区别和联系
JVM ：英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟
机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码
指令进行识别并调用操作系统向上的 API 完成动作。  
JRE ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环
境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相
对于 jvm 来说，多出来的是一部分的 Java 类库。  
JDK ：英文名称（Java Development Kit），Java 开发工具包。jdk 是
整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例
如：javac.exe，java.exe，jar.exe 等。  

# Java中Arrays.sort()如何实现排序
小于286进入五轴快排；  
大于286进行检查数组结构， 无结构进行归并排序；否则快排；   
双轴快排算法步骤:
1. 对于很小的数组（长度小于47），会使用插入排序。  
2. 选择两个点P1,P2作为轴心，比如我们可以使用第一个元素和最后一个元素。
3. P1必须比P2要小，否则将这两个元素交换，现在将整个数组分为四部分：
   （1）第一部分：比P1小的元素。
   （2）第二部分：比P1大但是比P2小的元素。
   （3）第三部分：比P2大的元素。
   （4）第四部分：尚未比较的部分。
   在开始比较前，除了轴点，其余元素几乎都在第四部分，直到比较完之后
   第四部分没有元素。
4. 从第四部分选出一个元素a[K]，与两个轴心比较，然后放到第一二三部分
中的一个。
5. 移动L，K，G指向。
6. 重复 4 5 步，直到第四部分没有元素。
7. 将P1与第一部分的最后一个元素交换。将P2与第三部分的第一个元素交换。
8. 递归的将第一二三部分排序。  

# JDK消费者生产者模型应用

# final修饰符
final可以修饰类，方法，变量（成员变量和局部变量）  
修饰类，终态类，类不能被继承。  
修饰方法，方法不能被重写。  
修饰变量，变量只能被赋值一次，不能被重新赋值，其实就是一个常量。对于
引用类型表示指向地址不变，但具体内容可变。

# 空接口作用
标志性作用；

# 浅克隆与深克隆
clone()这个方法是从Object继承下来的，一个对象要实现克隆，需要实现一
个叫做Cloneable的接口。  
Object中的克隆方法是浅度克隆，JDK规定了克隆需要满足的一些条件，简要
总结一下就是：对某个对象进行克隆，对象的的成员变量如果包括引用类型
或者数组，那么克隆的时候其实是不会把这些对象也带着复制到克隆出来的
对象里面的，只是复制一个引用，这个引用指向被克隆对象的成员对象，但
是基本数据类型是会跟着被带到克隆对象里面去的。而深度可能就是把对象
的所有属性都统统复制一份新的到目标对象里面去。
浅克隆：clone()；  
深克隆：重写clone()；利用序列化；  

# char、中文字符
Java的char内部编码为UTF-16；  
在UTF-16编码中，大于U+10000码位将被编码为一对16比特长的码元，即按4
个字节编码，此时char无法表示。  

# RTTI
运行时类型信息可以让你在程序运行时发现和使用类型信息。  
三种情况会触发Class Loader动态加载class对象到JVM：  
（1）第一次静态方法被调用；  
（2）第一次被new实例化；  
（3）包含静态代码块；  
取得Class对象(若还未加载则先加载)的引用有两种方式：  
（1）方法Class.forName("className")   
（2） .class 类字面常量。不会将类的初始化；  

# 什么是反射机制
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有
属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这
种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

# 反射机制优缺点
优点：可以实现动态创建对象和编译，体现出很大的灵活性；
缺点：反射操作的效率要比那些非反射操作低得多；安全限制 ；内部暴露，
破坏了封装性；

# 获取Class对象的三种方式
1. Object ——> getClass();  
2. 任何数据类型（包括基本数据类型）都有一个“静态”的class属性  
3. 通过Class类的静态方法：forName（String  className）(常用)  

# Java反射中Class.forName和classloader的区别
Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解
释，执行类中的static块。  
而classloader只干一件事情，就是将.class文件加载到jvm中，不会执
行static中的内容，只有在newInstance才会去执行static块。  

# 注解
常见的作用有以下几种：  
1.生成文档。这是最常见的，也是java 最早提供的注解。常用的
有@see @param @return 等；  
2.跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开
始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配
置来减少配置文件的数量；  
3.在编译时进行格式检查。如@Override放在方法前，如果你这个方法并不是
覆盖了超类方法，则编译时就能检查出；  

自定义注解类编写的规则：  
注解类型定义为 @interface，所有的注解会自动继
承 java.lang.Annotation 这一接口，而且不能再去继承其他的类或接口；  
参数成员只能用 public 或 default 两个关键字修饰；  
参数成员只能用基本类型：byte, short, char, int, long, 
float, double, boolean，以及 String, Enum, Class, Annotations 等数
据类型，以及这些类型的数组；  
要获取类方法和字段的注解信息，必须通过 Java 的反射技术；  
注解也可以不定义成员变量，但这样的注解没有什么卵用；  
自定义注解需要使用元注解进行编写；  
 
# 面向对象编程与面向过程编程的区别
面向过程是指在遇到问题的时候，怎么去解决这个问题，而分析问题的步骤，
就是解决这个问题的方法，是通过方法一步一步来完成的。面向对象是指在
遇到问题的时候，把问题分解成各自独立功能的类，而这个类是完成各自问
题的。总结如下所述。  
面向过程和面向对象最明显的区别就是，面向对象是按照要完成的功能来实
现的，而面向过程是按照解决这个问题的步骤来实现的。  
面向对象是按照程序中的功能进行划分的。  
面向过程是按照问题的解决思路来划分的，是一步一步来解决问题的。  
面向过程更看重的是完成问题的过程。  
面向对象更看重的是功能，通过各种功能模块的组合来完成问题。

# 内部类
1. 内部类可以直接访问外部类中的成员，包括私有。访问格式：外部类
名.this；外部类要访问内部类必须创建内部类对象。内部类在成员位置
上，可以被成员修饰符修饰。
2. 静态内部类；静态内部类 只能访问外部类的静态成员；
3. 局部内部类；内部类定义在局部时，可以直接访问外部类中的成员。访问
局部变量必须被final修饰。
4. 匿名内部类；匿名内部类是内部类的简写格式。匿名内部类的前提：内部
类必须继承一个类或者实现接口。匿名内部类不能创建构造函数。

#  为什么非静态内部类里面不能定义静态方法、静态成员变量、静态初始化块
静态属性不依赖于对象，所以访问修改的时候不需要依赖当前有没有存活的
对象。内部类其实也可以认为是外部类的一个成员变量，想要访问内部类，必
须先实例化外部类，然后通过外部类才能访问内部类。只要是成员变量，就需
要依赖具体的对象，这个时候如果在非静态内部类里面声明静态属性就会破
坏了这一逻辑，所以java语言在语义层面不允许我们那么做。

# 动态代理
## 代理模式
![](./markdownFile/代理模式.png)
代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。  
动态代理：在程序运行过程中产生的这个对象  
## 动态代理代码示例
````
//写一个类实现InvocationHandler接口
public class MyInvocationHandler implements InvocationHandler {
    private Object target; // 目标对象；被代理对象
    
    public MyInvocationHandler(Object target) {
        this.target = target;    
    }

    //重写invoke()方法
    public Object invoke(Object proxy, Method method, Object[] args) 
    throws Throwable {        
        System.out.println("权限校验");
        Object result = method.invoke(target, args);
        System.out.println("日志记录");
        return result; // 返回的是代理对象
    }
}
````
````
MyInvocationHandler handler = new MyInvocationHandler(ud);
// 获取代理对象；newProxyInstance方法第一个参数是实际主体的类加载器；
// 第二个是da代理对象与实际主体的一致性接口；
UserDao proxy = (UserDao) Proxy.newProxyInstance(ud.getClass()
.getClassLoader(), ud.getClass().getInterfaces(), handler);
proxy.add();
proxy.delete();
proxy.update();
proxy.find();
````
## JDK动态代理和cglib动态代理有什么区别
JDK动态代理只能对实现了接口的类生成代理对象；  
cglib可以对任意类生成代理对象，它的原理是对目标对象进行继承代理，
如果目标对象被final修饰，那么该类无法被cglib代理。
## SpringAOP的本质就是动态代理
SpringAOP混合使用。如果被代理对象实现了接口，就优先使用JDK代理，如
果没有实现接口，就用用cglib代理。

# 如何获取父类的类名
getClass()方法在Object类中被定义为final与native，子类不能覆盖该方
法。因此，this.getClass()和super.getClass()最终都调用的是Object类
中的getClass()方法。而Object类的getClass()方法的的功能是“返回
本Object类的运行时的类”。    
通过的反射机制，使用getClass().getSuperclass().getName()。

# 泛型
## 什么是泛型？为什么要使用泛型？
泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于
方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），
然后在使用/调用时传入具体的类型（类型实参）。  
泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定
的不同类型来控制形参具体限制的类型）。增加类的可复用性。
## 什么是 Java 泛型中的限定通配符和非限定通配符？有什么区别？
限定通配符对类型进行限制，泛型中有两种限定通配符，一种
是 <? extends T> 来保证泛型类型必须是 T 的子类来设定泛型类型的上
边界，另一种是 <? super T> 来保证泛型类型必须是 T 的父类来设定类型
的下边界，泛型类型必须用限定内的类型来进行初始化，否则会导致编译
错误。非限定通配符 <?> 表示可以用任意泛型类型来替代，可以在某种意
义上来说是泛型向上转型的语法格式，因为 List<String> 与 List<Object>
 不存在继承关系。
## 简单说说 List\<Object> 与 List 原始类型之间的区别？  
主要区别有两点。  
原始类型和带泛型参数类型 \<Object> 之间的主要区别是在编译时编译器不
会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过
使用 Object 作为类型可以告知编译器该方法可以接受任何类型的对象（
比如 String 或 Integer）。  
我们可以把任何带参数的类型传递给原始类型 List，但却不能
把 List\<String> 传递给接受 List\<Object> 的方法，因为会产生编
译错误。
## List\<Object> 与 List\<?> 类型之间的区别
我们可以把 List\<String>、List\<Integer> 赋值给 List\<?>，却不能
把 List\<String> 赋值给 List\<Object>.
## Java 中不能创建泛型数组
由于泛型擦除，结果就是泛型的检查作用失效，可以将 List<Integer> 
类型的值添加到 List<String>[] 类型的数组中。而这类问题在编译时无法
发现，只能在运行时出现问题。
## 什么是泛型擦除
泛型擦除就是类型变量用第一个限定来替换,如果没有给定限定就用Object替
换。只在编译期进行，不影响程序性能。
# try-catch-finally执行过程? finally是不是一定会执行?
不管有没有捕获到异常，finally中的代码块均会被执行  
finally是在return之后执行的，程序在执行完return之后，会将值保存起
来，当执行完finally中的代码块之后，再将return的值进行返回  
如果finally中存在return时，会导致最终返回的结果，就是finally中的
值，而不会是try或者catch中的值  
如果在finally中存在return时，会导致程序提前退出  

finally不是一定会执行:  
主动调用System.exit(0);  
Daemon线程是一种支持性线程，称之为守护线程;

# 装箱与拆箱
装箱就是将基本数据类型转化为包装类型，那么拆箱就是将包装类型转化
为基本数据类型。
Integer的valueOf（int i）方法可以将一个基本数据类型转化为对应的包
装类型，即装箱方法。
而Integer的intValue（）方法则可以将一个包装类型转化为对应的基本数
据类型，即拆箱方法。
观察Integer类的源码中的valueOf（）：
````
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
````
当i的值位于[-128,127]的时候，会直接返回Integer缓存数组中相应对象的
引用，如果i大于127或小于-128，会重新创建一个Integer实例，并返回。  
Byte、Short、Integer、Long、Character的valueOf（）实现机制类似。  
但是Float、Double中的valueOf（），永远返回新创建的对象，因为一个范
围内的整数是有限的，但是小数却是无限的，无法保存在缓存中。
````
public class TestBox3 {
    public static void main(String[] args) {
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Long d = 2L;
        Long e = 3L;
        int f = 2;
 
        //一旦有包装类型和数值类型判断==时，则触发包装类型的自动拆箱，转为数值类型的比较
        System.out.println(new Integer(300) == 300);//返回true
 
        //一旦有包装类型和数值类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算
        System.out.println(c == (a + f));//返回true
 
        //一旦有包装类型和包装类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算
        System.out.println(c == (a + b));//返回true
 
        //只有对象类型才有equals方法，因此首先a,b触发包装类型的自动拆箱，转为数值类型的运算。
        //运算完，再将结果3自动装箱，Integer重写了equals,因此可以转为包装类型与包装类型的比较。
        //当两边的包装类型不一致时，必定返回false。
        //当两边的包装类型一致时,再进行拆箱，判断两者代表的数值是否相等。
        System.out.println(c.equals(a + b));//返回true
 
        //不同数据类型的数值进行运算，首先会将低精度的数据类型转化为高精度的数据类型，即自动类型转换。
        //比如现在的int+long,会提升到long+long,再进行运算。
        System.out.println(e == (a + d));//返回true
 
        //==号两边类型不一致时，直接执行自动拆箱，比较之后的数值
        System.out.println(e == (a + b));//返回true
 
        //依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，拆箱，数值比较
        System.out.println(e.equals(a + d));//返回true
 
        //依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，两边类型不一致，直接返回false
        System.out.println(c.equals(a + d));//返回false
 
 
    }
}
````

# 处理异常主要有两种方式
* try{} 中放入可能发生异常的代码。catch{}中放入对捕获到异常之后的处
理。其中catch中e.printStackTrace()作用就是,在控制台打印程序出错的
位置及原因。
* throw是语句抛出异常，出现于函数内部，用来抛出一个具体异常实
例，throw被执行后面的语句不起作用，直接转入异常处理阶段。  
throws是函数方法抛出异常，一般写在方法的头部，用来抛出一些异常，本
身不进行解决，抛给方法的调用者进行解决(try catch)。

# static
用法：是一个修饰符，用于修饰成员（成员变量，成员函数）；
## 实例变量和类变量的区别：
   1，存放位置。  
   　　类变量随着类的加载而存在于方法区中。  
   　　实例变量随着对象的建立而存在于堆内存中。  
   2，生命周期：  
   　　类变量生命周期最长，随着类的消失而消失。  
   　　实例变量生命周期随着对象的消失而消失。  
## static特点：
1，随着类的加载而加载，也就是说静态会随着类的消失而消失，说明他的生命周期最长   
2，优先于对象的存在。（静态先存在，对象后存在。）   
3，被所有对象所共享  
4，可以直接被类名调用
## 静态使用注意事项：
1，静态方法只能访问静态成员，非静态方法既可以访问静态也可以访问非静
态。（Java虚拟机（JVM）加载类时，就会执行该static，静态优先于其他
产生对象产生）。  
2，静态方法中不可定义this，super等关键字：（this:this代表当前对
象，static于类加载的时候存在优先于实例对象的产生，static调用非静态
时并未产生对象，所以this不代表任何对象为null,未进行初始化操作。）  
3，主函数是静态方法。   
## static方法能否被覆盖? private方法能不能被覆盖?
都不能；

## 抽象类和接口区别
抽象类可以实现某些方法的部分实现  
接口只能提供方法而不能实现  
接口如果添加了一个新的方法，那所有继承这个接口的类都得添加这个方法，
否则会报错。  
抽象类中添加新的方法，你可以给它提供默认的实现，因此你不需要改变你
现在的代码。  
抽象方法可以有public、protected和default这些修饰符  
接口方法默认修饰符是public,不可以使用其他修饰符。  
抽象类只能实现单继承  
接口可以实现多继承，在实际使用中接口更加灵活，便于系统维护。  
abstract class表示的是"is a"关系，interface表示的是"like a"关系；

# 重载条件
相同的名字，但参数不同；  
参数不同包括两方面的内容：一是参数的类型不同，二是参数的个数不同；  

# 重写条件
子类覆盖父类要遵循“两同两小一大”；  
“两同”即方法名相同，形参列表相同  
“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，
子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等。
（注：看到有网友有这样的疑问，父类方法返回值是double，子类修改
成int为什么不行呢？
这是因为返回值类型更大或者更小，是对于同一类型而言的。也就是说，返
回值的类型需要有继承关系才去考虑大小这个 概念。类型不同，肯定不是
方法重写）  
“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。  

# 什么是异常？
Java中所有的异常都是Throwable类的子类;  
异常是Java程序用来指示一个错误信息的事件;  
Java中的异常分为两大类：  
* Error——系统异常，这类异常通常不是程序员或者用户可以控制的，例如OutOfMemoryError，内存
不足错误，或者我们以前看到过的堆栈溢出错误  
– 这类异常通常不需要捕获，在运行中遇到这类情况的时候，应该重新规划程序以避免这类错误
* Exception——由于程序或调用引起的异常状况，这类异常分为两大类：  
– 普通异常——Exception或其子类（除RuntimeException）  
– 运行时异常——RuntimeException或其子类  
 
# 序列化
* 把对象转换为字节序列的过程称为对象的序列化。
* 把字节序列恢复为对象的过程称为对象的反序列化。
## 序列化作用
* 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
* 在网络上传送对象的字节序列。
## 为什么要使用SerialversionUID呢
如果用户没有自己声明一个serialVersionUID,接口会默认生成一
个serialVersionUID。但是强烈建议用户自定义一个serialVersionUID,因
为默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会
导致InvalidClassException这个异常。  
如果没有为类指定serialVersionUID，则JVM会自动根据类的内容生成一
个serialVersionUID，类中的任何变化均会导致serialVersionUID的变
化，如新增一个空格。  
若对象已经修改较多或者修改成不兼容的模式，导致原来输出到磁盘的内容
不应再转换至原对象，此时则应该修改serialVersionUID。  
## 被static或transient修饰的属性能被序列化吗
不能。

# Comparable和Comparator
Comparable和Comparator都是用于比较数据的大小的，实现Comparable接口
需要重写compareTo方法，实现Comparator接口需要重写compare方法，这两
个方法的返回值都是int，用int类型的值来确定比较结果，在Collections工
具类中有一个排序方法sort，此方法可以之传一个集合，另一个重载版本是
传入集合和比较器，前者默认使用的就是Comparable中的compareTo方法，
后者使用的便是我们传入的比较器Comparator，java的很多类已经实现
了Comparable接口，比如说String，Integer等类。  
Comparable接口中只有一个方法：
````
public int compareTo(T o);
````
Comparator接口中方法很多，但是我们只需要实现一个：
````
int compare(T o1, T o2);
````

# Java正则表达式

# Java中socket连接过程
* 使用Socket进行网络通信的过程:  
1. 服务器程序将一个套接字绑定到一个特定的端口，并通过此套接字
等待和监听客户的连接请求。  
2. 客户程序根据服务器程序所在的主机名和端口号发出连接请求。  
3. 如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端
口地址的套接字。    
4. 客户和服务器通过读、写套接字进行通讯。
* 使用TCP/IP的套接字进行通信步骤
1) 建立Socket连接
2) 获得输入/输出流
3）读/写数据
4) 关闭输入/输出流
5) 关闭Socket

# Java 中的编译期常量是什么？使用它有什么风险？
在java中，static final修饰的是常量。根据编译器的不同行为，常量
又可分为编译时常量和运行时常量。  
编译期常量指的就是程序在编译时就能确定这个常量的具体值；它是不依
赖于类的，在编译时就可以确定值。  
非编译期常量就是程序在运行时才能确定常量的值，因此也称为运行时常量  
；它是依赖于类的，它的赋值会引起类的初始化。  
编译时常量，在使用时会被直接写成值，而不会再从原来的类中读取。这
样就会导致问题的产生：如果A类定义了常量，B类使用了常量，并且都
进行了编译。当A类的源码被改动了，常量的值发生了变化。我们对A类
进行了重新编译，但是没有对B类进行重新编译；那么B类中用到的是
原来A类中的常量值，即旧值。这就导致了风险的发生。
 
# Java中的引用有哪些类型?
强引用、软引用、弱引用和虚引用；
## 强引用（StrongReference）
只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在
内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
## 软引用（SoftReference）
软引用是用来描述一些有用但并不是必需的对象，在Java中
用java.lang.ref.SoftReference类来表示。对于软引用关联
着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可
以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如
网页缓存、图片缓存等。
````
import java.lang.ref.SoftReference;
 
public class Main {
    public static void main(String[] args) {
        SoftReference<String> sr = new SoftReference<String>(new String("hello")); 
        System.out.println(sr.get());
    }
}
````
## 弱引用（WeakReference）
弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否
充足，都会回收被弱引用关联的对象。在java中，
用java.lang.ref.WeakReference类来表示。
## .虚引用（PhantomReference）
虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java
中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关
联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

# 构造方法能不能被继承? 有没有返回值?
不能；没有；

# this()写第一行的原因? super()写第一行的原因? 可以写在一起吗?
super()在第一行的原因就是：子类有可能访问了父类对象, 比如在构造函数
中使用父类对象的成员函数和变量, 在成员初始化使用了父类, 在代码块中
使用了父类等, 所以为保证在子类可以访问父类对象之前要完成对父类对象
的初始化。  
this()在第一行的原因就是：为保证父类对象初始化的唯一性. 我们假设一
种情况, 类B是类A的子类, 如果this()可以在构造函数的任意行使用, 那么
会出现什么情况呢? 首先程序运行到构造函数B()的第一行, 发现没有调
用this()和super(), 就自动在第一行补齐了super() , 完成了对父类对象
的初始化, 然后返回子类的构造函数继续执行, 当运行到构造函数B()
的"this(2) ;"时, 调用B类对象的B(int) 构造函数, 在B(int)中, 还会对父
类对象再次初始化! 这就造成了对资源的浪费, 当然也有可能造成某些意想
不到的结果, 不管怎样, 总之是不合理的, 所以this() 不能出现在除第一
行以外的其他行！

# Java类初始化顺序
一个类中包含如下几类东西，他们前后是有顺序关系的:  
静态属性：static 开头定义的属性  
静态方法块： static {} 圈起来的方法块  
普通属性： 未带static定义的属性  
普通方法块： {} 圈起来的方法块  
构造函数： 类名相同的方法  
方法： 普通方法  
## 继承的子类：
   父类静态变量  
   父类静态代码块  
   子类静态变量  
   子类静态代码块  
   父类普通变量  
   父类普通代码块  
   父类构造函数  
   子类普通变量  
   子类普通代码块  
   子类构造函数  
## 抽象的实现子类: 接口 - 抽线类 - 实现类
   接口静态变量  
   抽象类静态变量  
   抽象类静态代码块  
   实现类静态变量  
   实习类静态代码块  
   抽象类普通变量  
   抽象类普通代码块  
   抽象类构造函数  
   实现类普通变量  
   实现类普通代码块  
   实现类构造函数  
   
# Collection与Collections的区别 
java.util.Collection 是一个集合接口（集合类的一个顶级接口）。
它提供了对集合对象进行基本操作的通用接口方法。    
Collections：Collections则是集合类的一个工具类/帮助类，其中提供
了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各
种操作。  

# 英文字母和中文汉字在不同字符集编码下的字节数
英文字母：
字节数 : 1;编码：GB2312
字节数 : 1;编码：GBK
字节数 : 1;编码：GB18030
字节数 : 1;编码：ISO-8859-1
字节数 : 1;编码：UTF-8
字节数 : 4;编码：UTF-16
字节数 : 2;编码：UTF-16BE
字节数 : 2;编码：UTF-16LE
  
中文汉字：
字节数 : 2;编码：GB2312
字节数 : 2;编码：GBK
字节数 : 2;编码：GB18030
字节数 : 1;编码：ISO-8859-1
字节数 : 3;编码：UTF-8
字节数 : 4;编码：UTF-16
字节数 : 2;编码：UTF-16BE
字节数 : 2;编码：UTF-16LE

# Java中System.arraycopy, Object.clone, Arrays.copyOf和for 4种数组复制方式的性能比较
在数组的长度不是很大的时候，基本遵循的规
律：System.arraycopy >Object.clone>Arrays.copyOf > for
原因总结：
（1）for循环拷贝（速度相对比较慢）
for的速度之所以最慢是因为下标表示法每次都从起点开始寻位到指定下标
处（现代编译器应该对其有进行优化，改为指针），另外就是它每一次循环
都要判断一次是否达到数组最大长度和进行一次额外的记录下标值的加
法运算。  
（2）Arrays.copyOf（浅拷贝）
查看Arrays.copyOf的源码可以发现，它其实本质上是调用
了System.arraycopy。之所以时间差距比较大，是因为很大一部分开销全
花在了Math.min函数上了。所以，相比之下，System.arraycopy效率要
高一些。  
（4）System.arraycopy（浅拷贝）
这个是系统提供的拷贝方式，也是我们推荐使用的拷贝方式，它是浅拷
贝，也就是说对于非基本类型而言，它拷贝的是对象的引用，而不是去
新建一个新的对象。通过它的代码我们可以看到，这个方法不是用java语
言写的，而是底层用c或者c++实现的，因而速度会比较快。  

# Servlet 是什么？
Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来
自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或
应用程序之间的中间层。
## Servlet 执行以下主要任务：
读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或
者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。  
读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒
体类型和浏览器能理解的压缩格式等等。  
处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 
调用，调用 Web 服务，或者直接计算得出对应的响应。  
发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种
多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、
Excel 等。  
发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客
户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及
其他类似的任务。  
## Servlet 创有三种方式。
1、实现 Servlet 接口  
2、继承 GenericServlet 类  
3、继承 HttpServlet 方法  
## Servlet 生命周期
* Servlet 通过调用 init () 方法进行初始化。init 方法被设计成只调用
一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再
调用。   
* Servlet 调用 service() 方法来处理客户端的请求。每次服务器接收
到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。    
* Servlet 通过调用 destroy() 方法终止（结束）。  
* 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。destroy() 
方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 
方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列
表或点击计数器写入到磁盘，并执行其他类似的清理活动。  
## 从客户端发起请求到接收到响应的处理流程:
客户端发送HTTP请求,这个请求首先会到达Tomcat内置Web服务器  
Tomcat内置Web服务器接收到请求后,会将请求发送到Servlet容器  
Servlet容器接收到请求后会加载Servlet,产生Servlet实例后会向其传递
表示请求和响应的对象,也就是HTTPServletRequest对象和
HTTPServletResponse对象,然后Servlet实例使用请求对象请求客户端的
请求信息并进行响应的处理  
该Servlet实例处理完成后有可能将请求发送给其他的Servlet继续进行
处理  
全部处理完毕后,处理结果通过显示对象发送回客户端浏览器  
## forward（转发）与redirect（重定向）的区别
forward:转发页面和转发到的页面可以共享request里面的数据；  
redirect:不能共享数据；  
forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的
响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务
器发送的内容从哪里来的,所以它的地址栏还是原来的地址.  
redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个
地址.所以地址栏显示的是新的URL.  
转发是服务器行为，重定向是客户端行为。  
## 过滤器链调用原理与顺序：
web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当
第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter
链的FilterChain对象传递给该方法。在doFilter方法（放行）中，开发人
员如果调用了FilterChain对象的doFilter方法，则web服务器会检
查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如
果没有，则调用目标资源。  
根据在web.xml文件中的顺序还决定调用的顺序：和<filter-mapping>的配
置先后顺序有关系.  
在开发中:Servlet,Filter,Listener配置先后问题： 一般先配
置Listener,再配置Filter,最后配置Servlet.  
# servlet安全性
Servlet体系结构是建立在Java多线程机制之上的，它的生命周期是由Web容器
负责的。当客户端第一次请求某个Servlet时，Servlet容器将会根
据web.xml配置文件实例化这个Servlet类。当有新的客户端请求该Servlet
时，一般不会再实例化该Servlet类，也就是有多个线程在使用这个实例。  
实例变量不正确的使用是造成Servlet线程不安全的主要原因。  
解决方案：  
同步对共享数据的操作；  
避免使用实例变量；
# Tomcat目录结构以及类加载顺序
tomcat的目录结构很清晰明了，下面来介绍一下：  
bin：存放Windows和Linux平台启动和关闭Tomcat的脚本文件  
conf：存放Tomcat的配置文件，server.xml可以配置端口号、项目访问服
务器的文件路径  
logs：存放tomcat的日志文件以及在javaWeb中配置的日志插件的默认存储
路径  
webapps：javaWeb应用在tomact发布的默认存放路径  
work：Tomcat的工作目录，Tomcat在运行时会把生成的一些工作文件存放
于此目录下，例如默认情况下，Tomcat把编译JSP而生成的Servlet类文件存
放在此目录下  
Tomcat启动时classloader加载顺序:  
Tomcat的class加载的优先顺序一览  
1.最先是$JAVA_HOME/jre/lib/ext/下的jar文件。  
2.环境变量CLASSPATH中的jar和class文件。  
3.$CATALINA_HOME/common/classes下的class文件。  
4.$CATALINA_HOME/commons/endorsed下的jar文件。  
5.$CATALINA_HOME/commons/i18n下的jar文件。  
6.$CATALINA_HOME/common/lib   下的jar文件。  
（JDBC驱动之类的jar文件可以放在这里，这样就可以避免在server.xml配
置好数据源却出现找不到JDBC   Driver的情况。）  
7.$CATALINA_HOME/server/classes下的class文件。  
8.$CATALINA_HOME/server/lib/下的jar文件。  
9.$CATALINA_BASE/shared/classes   下的class文件。  
10.$CATALINA_BASE/shared/lib下的jar文件。  
11.各自具体的webapp   /WEB-INF/classes下的class文件。  
12.各自具体的webapp   /WEB-INF/lib下的jar文件。

# 同步集合类
* Hashtable  
* Vector  
* 同步集合包装类，Collections.synchronizedMap()
和Collections.synchronizedList()   
# 并发集合类  
* ConcurrentHashMap
* CopyOnWriteArrayList
* CopyOnWriteHashSet
## 并发集合的实现原理
ConcurrentHashMap：把整个Map 划分成几个片段，只对相关的几个
片段上锁，同时允许多线程访问其他未上锁的片段。  
CopyOnWriteArrayList：允许多个线程以非同步的方式读，当有线程写的
时候它会将整个List复制一个副本给它。如果在读多写少这种对并发集合
有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。
## 同步集合类、并发集合类性能区别
同步集合比并发集合会慢得多，主要原因是锁，同步集合会对整个May
或List加锁；
# ConcurrentHashMap实现原理
ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。
Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的
角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含
一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表
结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链
表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当
对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。  
# 什么是CopyOnWrite容器
CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加
元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出
一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的
引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发
的读，而不需要加锁，因为当前容器不会添加任何元素。所
以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。
## CopyOnWrite的应用场景
 CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商
 品类目的访问和更新场景；
## CopyOnWrite的缺点
内存占用问题；  
数据一致性问题；CopyOnWrite容器只能保证数据的最终一致性，不能保证
数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要
使用CopyOnWrite容器。

# Collection集合的基本结构：
![](./markdownFile/java集合.jpg)  
## Collection接口
Collection是最基本集合接口,定义了集合的一些基本操作；
Collection接口派生了两个子接口Set和List；
### Set接口
实现了Set接口的集合类中的元素是无序且不可重复。
### List接口
List接口的集合类中的元素是对象有序且可重复。  
两个重要的实现类：ArrayList和LinkedList；
### Map接口
该接口描述了从不重复的键到值的映射。  
两个重要的实现类：HashMap和TreeMap；
### Iterator接口
集合访问器，用于循环访问集合中的对象。
### Comparable接口
Comparable可以用于比较的实现，实现了Comparable接口的类可以通过
实现comparaTo方法从而确定该类对象的排序方式。
# 为什么集合没有实现Cloneable和Serializable
克隆（cloning）或者序列化（serialization）的语义和含义是跟具
体的实现相关的。因此应该由集合类的具体实现类来决定如何被克隆或
者序列化。
# Iterator和ListIterator主要区别在以下方面：
1. iterator()方法在set和list接口中都有定义，但是ListIterator（）
仅存在于list接口中（或实现类中）；
2. ListIterator有add()方法，可以向List中添加对象，而Iterator不能
3. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序
向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实
现逆向（顺序向前）遍历。Iterator就不可以。
4. ListIterator可以定位当前的索引位置，nextIndex()
和previousIndex()可以实现。Iterator没有此功能。
5. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方
法可以实现。Iierator仅能遍历，不能修改。　　
# Enumeration接口和Iterator接口的区别
Enumeration 接口的作用与 Iterator 接口类似，但只提供了遍历 Vector 
和 Hashtable 类型集合元素的功能，不支持元素的移除操作。  
````
for (Enumeration<E> e = v.elements();e.hasMoreElements();)
       System.out.println(e.nextElement());
````
Enumeration速度是Iterator的2倍，同时占用更少的内存。但
是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在
被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底
层集合里面的元素，这对Enumeration来说是不可能的。
# 快速失败(fail-fast)和安全失败(fail-safe)区别
一：快速失败（fail—fast）
在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行
了修改（增加、删除、修改），则会抛
出Concurrent Modification Exception。
原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用
一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改
变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素
之前，都会检测modCount变量是否为expectedmodCount值，是的话就返
回遍历；否则抛出异常，终止遍历。
注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个
条件。如果集合发生变化时修改modCount值刚好又设置为
了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是
否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。
场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并
发修改（迭代过程中被修改）。
二：安全失败（fail—safe）
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，
而是先复制原有集合内容，在拷贝的集合上进行遍历。
原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集
合所作的修改并不能被迭代器检测到，所以不会触
发Concurrent Modification Exception。
缺点：基于拷贝内容的优点是避免
了Concurrent Modification Exception，但同样地，迭代器并不能访问
到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷
贝，在遍历期间原集合发生的修改迭代器是不知道的。
场景：java.util.concurrent包下的容器都是安全失败，可以在多线程
下并发使用，并发修改。
# 数组和列表的区别 
数组初始化后大小固定，且数据都已经被赋值；  
list移除某一元素后，后续元素会前移；  
数组不能删除制定位置元素，除非重建数组对象；  
在性能要求较高的场景中请优先考虑数组。
# Set
## TreeSet
1、不能有重复的元素；  
2、具有排序功能；  
3、TreeSet中的元素必须实现Comparable接口并重写compareTo()方法，
TreeSet判断元素是否重复 、以及确定元素的顺序 靠的都是这个方法；  
①对于Java类库中定义的类，TreeSet可以直接对其进行存储，
如String，Integer等,因为这些类已经实现了Comparable接口);
②对于自定义类，如果不做适当的处理，TreeSet中只能存储一个该
类型的对象实例，否则无法判断是否重复。  
4、依赖TreeMap。  
5、相对HashSet,TreeSet的优势是有序，劣势是相对读取慢。根据不
同的场景选择不同的集合。  
### TreeSet的底层实际使用的存储容器就是TreeMap。
对于TreeMap而言，它采用一种被称为”红黑树”的排序二叉树来保
存Map中每个Entry。每个Entry被当成”红黑树”的一个节点来对待。
## HashSet
简单的理解就是HashSet对象中不能存储相同的数据，存储数据时是无序
的。但是HashSet存储元素的顺序并不是按照存入时的顺序（
和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。
### HashSet的底层实际使用的存储容器就是HashMap。
## LinkedHashSet
是Set集合的一个实现，具有set集合不重复的特点，同时具有可预测的迭代
顺序，也就是我们插入的顺序。
### LinkedHashSet的底层实际使用的存储容器就是LinkedHashMap。

# Map
## HashMap
根据键的hashCode值存储数据，直接定位到它的值，因而具有很快的访问
速度，但遍历顺序却是不确定的。   
HashMap最多只允许一条记录的键为null，允许多条记录的值为null。  
HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会
导致数据的不一致。如果需要满足线程安全，可以用 Collections的
synchronizedMap方法使HashMap具有线程安全的能力，或者使用
ConcurrentHashMap。  
Jdk1.8之前 数组+链表；jdk1.8 数组+链表+红黑树；  
### 存储结构
![](./markdownFile/HashMap.png)
哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java
中HashMap采用了链地址法。  
链地址法，简单来说，就是数组加链表的结合。在数组的每个元素上都
一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标
元素的链表上。  
### HashMap 的长度为什么是2的幂次方
为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配
均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链
表/红黑树中的算法。
这个算法应该如何设计呢？
我们首先可能会想到采用%取余的操作来实现。但是，重点来
了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的
与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length
是2的 n 次方；）。” 并且采用二进制位操作 &，相对于%能够提高运
算效率，这就解释了 HashMap 的长度为什么是2的幂次方。
### 确定哈希桶数组索引位置

### 分析HashMap的put方法

### 扩容机制

### HashMap 多线程操作导致死循环问题

### HashMap链表插入是头插入还是尾插入? 头插入会造成什么问题?
在jdk1.8之前是插入头部的，在jdk1.8中是插入尾部的。
链表头插法的会颠倒原来一个散列桶里面链表的顺序。在并发的时候原来的
顺序被另外一个线程a颠倒了，而被挂起线程b恢复后拿扩容前的节点和顺
序继续完成第一次循环后，又遵循a线程扩容后的链表顺序重新排列链表中
的顺序，最终形成了环。  
当两个线程分别对hashmap进行插入操作 并且引发了扩展的操作，在这种
情况下采用头插法的话  重新扩展后的定位又是在同一个桶的话  那很容易
导致成环  死循环出不来  最主要原因是null值的丢失。  
如果采用尾插法的话null值不会丢失 就算是多线程导致扩展也不会导致死
循环的情况出现  最多只是丢失一部分数据（如果是直接在尾部插入）。  

### 为什么HashMap里数组使用transient修饰?
对于HashMap来说（以及底层实现是利用HashMap的HashSet），由于不同
的虚拟机对于相同hashCode产生的Code值可能是不一样的（这个我也不
清楚咋回事，可自行到StackOverFlow上查找问题），如果你使用默认的
序列化，那么反序列化后，元素的位置和之前的是保持一致的，可是由
于hashCode的值不一样了，那么定位函数indexOf（）返回的元素下标
就会不同，这样不是我们所想要的结果

### HashMap为什么用红黑树而不用AVL树?
红黑树和AVL树都是最常用的平衡二叉搜索树，它们的查找、删除、修
改都是O(lgn) time;  
AVL树和红黑树有几点比较和区别：  
（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取
查找密集型任务，适用AVL树。  
（2）红黑树更适合于插入修改密集型任务。  
（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。  

## HashTable
承自Dictionary类，并且是线程安全的，任一时间只有一个线程能
写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引
入了分段锁。   
 HashTable容器使用synchronized来保证线程安全; 

## ConcurrentHashMap
ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存
储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数
据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比
如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某
个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的
锁。这里“按顺序”是很重要的，否则极有可能出现死锁，
在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也
是final的，但是，仅仅是将数组声明为final的并不保证数组成员也
是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁
的顺序是固定的。  
ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。
Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁
的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里
包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链
表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个
链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对
HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。  
Concurrenthashmap如何扩容。扩容的时候首先会创建一个两倍于原容量
的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了
高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进
行扩容。  

## ConcurrentHashMap与HashMap、HashTable等的区别

## TreeMap
实现NavigableMap接口，NavigableMap继承SortedMap，能够把它保存的记
录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当
用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映
射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口
或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛
出java.lang.ClassCastException类型的异常。  
## LinkedHashMap
HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历
LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参
数，按照访问次序排序。  
# 阻塞队列
## ArrayBlockingQueue

## LinkedBlockingQueue

## PriorityBlockingQueue

## DelayQueue

## SynchronousQueue

## 非阻塞队列


# 进程、线程
进程(Process)：一个程序运行起来时在内存中开辟一段空间用来运行程
序，这段空间包括heap、stack、data segment和code segment。  
进程是操作系统调度和分配资源的基本单位，进程之间的通信需要通过
专门的系统机制，比如消息、socket和管道来完成。  
而线程是比进程更小的执行单位，每个线程拥有自己的栈和寄存器等资
源数据，多个线程之间共享进程的代码、数据和文件。
## 线程的优点有如下几条：  
 1. 创建一个线程比创建一个进程的代价要小
 2. 线程的切换比进程间的切换代价小
 3. 充分利用多处理器
 4.  数据共享（数据共享使得线程之间的通信比进程间的通信更高效）
 5.  快速响应特性（在系统繁忙的情况下，进程通过独立的线程及时响应用户的输入 ）
## 线程的实现
* 继承Thread类
在Java中可通过继承java.lang.Thread类来实现线程；而完成线程真正功能的代码
在run()方法中；之后通过调用start()方法启动线程，如果start()方法调用一个
已经启动的线程，会抛出IllegalThreadStateException异常。
* 实现Runnable接口
* 实现Callable接口
## 线程状态
![](./markdownFile/线程状态.png)
![](./markdownFile/线程状态1.jpg)
1. 新建状态(New)：   
当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运
行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有
开始运行线程中的代码。
2. 可运行状态
* 调用线程的start()方法，此线程进入可运行状态。
* 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某
个线程拿到对象锁，这些线程也将进入可运行状态。
* 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入可
运行状态。
* 锁池里的线程拿到对象锁后，进入可运行状态。
3. 运行状态
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。
这也是线程进入运行状态的唯一一种方式。
4. 死亡状态
当线程的run()方法完成时，或者被异常打断时，我们就认
为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行
的线程。线程一旦死亡，就不能复生。  
在一个死去的线程上调用start()方法，会抛
出java.lang.IllegalThreadStateException异常。
5. 阻塞状态
* 当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态。
* 运行在当前线程里的其它线程t2调用join()方法，当前线
程进入阻塞状态。
* 等待用户输入的时候，当前线程进入阻塞状态。
6. 等待队列  
调用obj的wait(), notify()方法前，必须获得obj锁; 调用wait()进入等待
状态；
7. 锁池状态  
当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此
时当前线程进入锁池状态。简言之，锁池里面放的都是想争夺对象锁的
线程。  
当一个线程1被另外一个线程2唤醒时，1线程进入锁池状态，去争夺对象
锁。  
锁池是在同步的环境下才有的概念，一个对象对应一个锁池。  

## 阻塞状态(Blocked)
线程运行过程中，可能由于各种原因进入阻塞状态:  
1>线程通过调用sleep方法进入睡眠状态；  
2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之
前不会返回到它的调用者；  
3>线程试图得到一个锁，而该锁正被其他线程持有；  
4>线程在等待某个触发条件；  

## 线程的休眠/加入/中断/礼让
* 线程的休眠  
当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可
运行状态。作用：给其它线程执行机会的最佳方式。
* 线程的加入(join)  
当某个线程使用join()方法加入到另一个线程时，另一个线程会等待该
线程执行完毕再继续执行。

* 线程的中断  
可在run()方法中使用无限循环的形式，然后使用一个布尔型标记控制循
环的停止。如下：
````
@Override
public void run() {
    while(true) {
        //... 此部分代码省略
        if(isContinue) {        //为true时，停止线程
            break;
        }
    }
}
````
* 关于中断：  
它并不像stop方法那样会中断一个正在运行的线程。  
线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值
是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打
断的线程会抛出InterruptedException。   
Thread.interrupted()检查当前线程是否发生中断，返回boolean;
synchronized在获锁的过程中是不能被中断的。  
中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以
说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检
查并抛出异常。如果在正常运行的程序中添
加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体.

*  线程的礼让  
Java线程中的Thread.yield( )方法，译为线程让步。当一个线程使用了这
个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程
运行，注意是让自己或者其他线程运行，并不是单纯的让给其他线程。实际
中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度
程序再次选中。Thread.yield()不会导致阻塞。

# Java如何捕获线程异常？
因为线程是独立执行的代码片断,我们不能捕获从线程中逃逸的异常。  
JDK5之后有了一个Thread.UncaughtExceptionHandler 新接口，
它允许我们在每一个Thread对象上添加一个异常处理器。
Thread.UncaughtExceptionHandler.uncaughtException()方法会在线程
因未捕获的异常而面临死亡时被调用。
````
public class MyUnchecckedExceptionhandler implements UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("捕获异常处理方法：" + e);
    }
}
````
三种方式使用该线程异常捕获器：  
在创建线程的时候进行设置；  
使用Executors创建线程时，还可以在TreadFactory中设置；  
可以设置一个默认的线程异常捕获器；

# Callable
future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone
和get。其中Future对象用来存放该线程的返回值以及状态
````
ExecutorService e = Executors.newFixedThreadPool(3);
 //submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.
Future future = e.submit(new myCallable());
future.isDone() //return true,false 无阻塞
future.get() // return 返回值，阻塞直到该线程运行结束
````

# 高级多线程控制类
## ThreadLocal类
用处：保存线程的独立变量。  
当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提
供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不
会影响其它线程所对应的副本。  
Spring使用ThreadLocal解决线程安全问题我们知道在一般情况下，只有
无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都
可以声明为singleton作用域，就是因为Spring对一些Bean
（如RequestContextHolder、TransactionSynchronizationManager、
LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让
它们也成为线程安全的状态，因此有状态的Bean就可以在多线程中共享
了。  
* void set(Object value)设置当前线程的线程局部变量的值。
* public Object get()该方法返回当前线程所对应的线程局部变量。
* public void remove()将当前线程局部变量的值删除，目的是为了减少
内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结
束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法
清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。
* protected Object initialValue()返回该线程局部变量的初始值，该
方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方
法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，
并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。
````
public class ConnectionManager {  
  
    private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {  
        @Override  
        protected Connection initialValue() {  
            Connection conn = null;  
            try {  
                conn = DriverManager.getConnection(  
                        "jdbc:mysql://localhost:3306/test", "username",  
                        "password");  
            } catch (SQLException e) {  
                e.printStackTrace();  
            }  
            return conn;  
        }  
    };  
  
    public static Connection getConnection() {  
        return connectionHolder.get();  
    }  
  
    public static void setConnection(Connection conn) {  
        connectionHolder.set(conn);  
    }  
}  
````
线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是
ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对
比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，
它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每
一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程
中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。
还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的
ThreadLocal对象，而值就是你所设置的对象了。

## 为什么ThreadLocal要使用弱引用
设计成弱引用的目的是为了更好地对ThreadLocal进行回收，当我们在代
码中将ThreadLocal的强引用置为null后，这时候Entry中的ThreadLocal
理应被回收了，但是如果Entry的key被设置成强引用则该ThreadLocal就
不能被回收，这就是将其设置成弱引用的目的
## ThreadLocal内存泄漏
弱引用一定程度上回收了无用对象，但前提是开发者手动清理掉
ThreadLocal对象的强引用。只要线程一直不死，ThreadLocalMap的
key-value一直在涨。
解决方法：当某个ThreadLocal变量（比如：TL_INT）不再使用时，记
得TL_INT.remove()，删除该key。

## 原子类

## Lock类　
lock: 在java.util.concurrent包内。共有三个实现：  
ReentrantLock  
ReentrantReadWriteLock.ReadLock  
ReentrantReadWriteLock.WriteLock  
和synchronized区别如下：
lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照
先加的后解顺序）  
提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily
 可打断式， 还有trylock的带超时时间版本。  
本质上和监视器锁（即synchronized是一样的）  
能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。  
和Condition类的结合。  
### ReentrantLock　　　　
可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后
才真正释放该锁。  
### ReentrantReadWriteLock
写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码
## 容器类
### BlockingQueue
阻塞队列。除了传统的queue功能（表格左边的两列）之外，还提供了阻
塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满
的时候阻塞，直到有空间时被唤醒；take在队　列空的时候阻塞，直到有
东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。
### ConcurrentHashMap
高效的线程安全哈希map。
## 管理类
### ThreadPoolExecutor
````
ExecutorService e = Executors.newCachedThreadPool();
    ExecutorService e = Executors.newSingleThreadExecutor();
    ExecutorService e = Executors.newFixedThreadPool(3);
    // 第一种是可变大小线程池，按照任务数来分配线程，
    // 第二种是单线程池，相当于FixedThreadPool(1)
    // 第三种是固定大小线程池。
    // 然后运行
    e.execute(new MyRunnableImpl());
````

# final对于线程
只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），
那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程
都能看到这个final域在构造函数中被初始化之后的值。

# 守护线程和用户线程
用户线程:平时用到的普通线程均是用户线程  
守护线程:指在程序运行的时候在后台提供一种通用服务的线程,守护线程
是为用户线程服务的,当有用户线程在运行,那么守护线程同样需要工作,当
所有的用户线程都结束时,守护线程也就会停止。Daemon线程中产生的新
线程也是Daemon。守护线程不应该去访问固有资源。

# 线程优先级
线程的优先级说明在程序中该线程的重要性。系统会根据优先级决定首
先使用哪个线程，但这并不意味着优先级低的线程得不到运行，只是它
运行的几率比较小而已。

# 同步方法和同步块
同步方法使用synchronized修饰方法，在调用该方法前，需要获得内置
锁（java每个对象都有一个内置锁），否则就处于阻塞状态；  
同步代码块使用synchronized(object){}进行修饰，在调用该代码块
时，需要获得内置锁，否则就处于阻塞状态；  
同步代码块尽量减少同步的内容；

# 线程池
## ThreadPoolExecutor
 线程池的最上层接口是Executor，这个接口定义了一个核心方法
 execute(Runnabel command)，这个方法最后被ThreadPoolExecutor类
 实现，这个方法是用来传入任务的。而且ThreadPoolExecutor是线程池
 的核心类，此类的构造方法如下：
````
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue);
 
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
    BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
```` 
构造方法的参数及意义：  
corePoolSize：核心线程池的大小。如果核心线程池有空闲位置，这时
新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线
程，线程会进入缓存队列等待再次被运行。  
maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓
存队列都已经满了，新的任务进来就会创建新的线程来执行。但是数量不
能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具
体分析。  
keepAliveTime：非核心线程能够空闲的最长时间，超过时间，线程终止。
这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线
程数量不超过核心线程大小，就不会起作用。  
unit：时间单位，和keepAliveTime配合使用。  
workQueue：缓存队列，用来存放等待被执行的任务。  
threadFactory：线程工厂，用来创建线程，一般有三种选择策略：    
````
 ArrayBlockingQueue;
 LinkedBlockingQueue;
 SynchronousQueue;
````  
handler：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理
策略，四种策略为:
````
ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出;
RejectedExecutionException异常。 线程池的默认拒绝策略;如果是比较
关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发
量的时候，能够及时的通过异常发现。

ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
一些无关紧要的业务采用此策略。
 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，
然后重新尝试提交被拒绝任务（重复此过程）

ThreadPoolExecutor.CallerRunsPolicy：由提交任务的线程处理该任务 
````   
## 线程池状态、线程池的关闭
线程池和线程一样拥有自己的状态，在ThreadPoolExecutor类中定义了
一个volatile变量runState来表示线程池的状态，线程池有四种状态，
分别为RUNNING、SHURDOWN、STOP、TERMINATED。  
线程池创建后处于RUNNING状态。  
调用shutdown后处于SHUTDOWN状态，线程池不能接受新的任务，会等待
缓冲队列的任务完成。  
调用shutdownNow后处于STOP状态，线程池不能接受新的任务，并尝试终
止正在执行的任务。  
当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务
缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。  
## 线程池工作原理(过程)
当我们把一个Runnable交给线程池去执行的时候，这个线程池处理的流
程是这样的：  
先判断线程池中的核心线程们是否空闲，如果空闲，就把这个新的任务
指派给某一个空闲线程去执行。如果没有空闲，并且当前线程池中的
核心线程数还小于 corePoolSize，那就再创建一个核心线程。  
如果线程池的线程数已经达到核心线程数，并且这些线程都繁忙，就把
这个新来的任务放到等待队列中去。  
如果等待队列又满了，那么查看一下当前线程数是否到
达maximumPoolSize，如果还未到达，就继续创建线程。  
如果已经到达了，就交给RejectedExecutionHandler来决定怎么处理这
个任务。  
# 为什么使用线程池
减少创建和销毁线程的开销；合理利用系统资源；  
为在请求到达时线程已经存在，所以无意中也消除了线程创建所带来的延迟。  
将处理请求的线程数量控制在一个范围，有利于操作系统稳定；
# 数据库连接池技术带来的优势：
 资源重用；  
 更快的系统响应速度；  
 统一的连接管理，避免数据库连接泄漏；  
# Java通过Executors提供四种线程池
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需
要，可灵活回收空闲线程，若无可回收，则新建线程。  
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超
出的线程会在队列中等待。  
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务
执行。  
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一
的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级
)执行。  
# synchronized
synchronized 关键字主要有以下几种用法：
- 非静态方法的同步；
- 静态方法的同步；
- 代码块。
## 对象锁
进行了同步的方法（加锁方法）和没有进行同步的方法（普通方法）是
互不影响的，一个线程进入了同步方法，得到了对象锁，其他线程还是
可以访问那些没有同步的方法（普通方法）。当获取到与对象关联的内
置锁时，并不能阻止其他线程访问该对象，当某个线程获得对象的锁之
后，只能阻止其他线程获得同一个锁。  
## 类锁
类锁和对象锁其实是一样的，由于静态方法是类所有对象共用的，所以
进行同步后，该静态方法的锁也是所有对象唯一的。每次只能有一个线
程来访问对象的该非静态同步方法。  
类锁和对象锁是不一样的锁，是互相独立的。
## synchronized与Lock比较
![](./markdownFile/synchronized与Lock比较.PNG)
# Lock
## ReentrantLock
默认情况下ReentrantLock会使用非公平锁的实现。  
AQS提供了ReentrantLock实现的基础。  

# AQS
使用一个volatile int类型成员变量表示同步状态；  
通过内置的FIFO队列完成资源获取线程的排队工作； 
自定义同步器实现时主要实现以下几种方法：
````
isHeldExclusively()：该线程是否正在独占资源。只有用
到condition才需要去实现它。
tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则
返回false。
tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则
返回false。
tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表
示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤
醒后续等待结点返回true，否则返回false。
```` 
### state的访问方式有三种:  
getState()  
setState()  
compareAndSetState()  
### AQS定义两种资源共享方式：  
Exclusive（独占，只有一个线程能执行，如ReentrantLock）和
Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。
### AQS方法
#### acquire(int)
函数流程如下：  
tryAcquire()尝试直接去获取资源，如果成功则直接返回；  
addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；  
acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返
回。如果在整个等待过程中被中断过，则返回true，否则返回false。  
如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进
行自我中断selfInterrupt()，将中断补上。  

tryAcquire(int)  
 tryAcquire尝试以独占的方式获取资源，如果获取成功，则直接返
 回true，否则直接返回false。该方法可以用于实现Lock中的tryLock()
 方法。该方法的默认实现是抛出UnsupportedOperationException，具
 体实现由自定义的扩展了AQS的同步类来实现。  
 
addWaiter(Node)  
该方法用于将当前线程根据不同的模式（Node.EXCLUSIVE互斥模式、
Node.SHARED共享模式）加入到等待队列的队尾，并返回当前线程所在
的结点。如果队列不为空，则以通过compareAndSetTail方法以CAS的
方式将当前线程节点加入到等待队列的末尾。否则，通过enq(node)方
法初始化一个等待队列，并返回当前节点。  

acquireQueued(Node, int)  
acquireQueued()用于队列中的线程自旋地以独占且不可中断的方式获取
同步状态（acquire），直到拿到锁之后再返回。该方法的实现分成两
部分：如果当前节点已经成为头结点，尝试获取锁（tryAcquire）成
功，然后返回；否则检查当前节点是否应该被park，然后将该线程park
并且检查当前线程是否被可以被中断。  
````
 final boolean acquireQueued(final Node node, int arg) {
    //标记是否成功拿到资源，默认false
    boolean failed = true;
    try {
        boolean interrupted = false;//标记等待过程中是否被中断过
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
````

#### release(int)
release(int)方法是独占模式下线程释放共享资源的顶层入口。它会
释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列
里的其他线程来获取资源。  

#### acquireShared(int)
acquireShared(int)方法是共享模式下线程获取共享资源的顶层入口。
它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待
队列，直到获取到资源为止，整个过程忽略中断。  
它的流程：  
tryAcquireShared()尝试获取资源，成功则直接返回；  
失败则通过doAcquireShared()进入等待队列park()，直到被
unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽
略中断的。  

# CAS
CAS全称Compare And Set（或Compare And Swap）,CAS包含三个操作数：
内存位置(V)、原值(A)、新值(B)。简单来说CAS操作就是一个虚拟机实
现的原子操作，这个原子操作的功能就是将旧值(A)替换为新值(B)，如
果旧值(A)未被改变，则替换成功，如果旧值(A)已经被改变则替换失
败。  
缺点：
ABA问题；  
循环时间长开销大；  
只能保证一个共享变量；  
## synchronized与cas比较
线程较少时cas比较快；

# volatile 
具备了可见性、有序性以及部分原子性；  
原子性，就是说一个操作是一个完整的整体，在其他线程看来这个操作
要么未开始，要么已完成，不会看到中间的操作过程；  
## volatile的“部分”原子性
volatile修饰的变量只能保证变量的读写是原子性的；  
大部分情况下单个变量的读取和赋值本身就具有原子性，但有一个例
外，就是32位Java虚拟机下的long/double型变量操作。
## volatile的可见性
对volatile修饰的变量的写对其他线程可见；
## volatile的有序性
对一个volatile变量的写操作happen—before后面对该变量的读操作。  
## volatile的两个典型使用场景
* 用来标示状态量。
* double-check问题
````
public class DoubleCheck {
    private volatile static DoubleCheck instance = null;  
    private DoubleCheck() {
        
    }
    public static DoubleCheck getInstance() {
        if (null == instance) {   //步骤一
            synchronized (DoubleCheck.class) {
                if (null == instance) {   //步骤二
                    instance = new DoubleCheck();   //步骤三
                }
            }
        }
        return instance;
    }
    public static void main(String[] args) throws InterruptedException {
        DoubleCheck doubleCheck = DoubleCheck.getInstance();
    }
}
````
# 非公平锁、公平锁
非公平锁在锁空闲的状态下再次CAS操作尝试获取锁，保证线程安全。如
果当前锁非空闲，也就是state状态不为0，则判断是否是重入锁，也就
是同一个线程多次获取锁，是重入锁则将state状态+1，这也是
ReentrantLock`支持锁重入的逻辑。  
公平锁在锁空闲时首先会调用hasQueuedPredecessors方法判断锁等待队
列中是否存在等待线程，如果存在，则不会去尝试获取锁，而是走接下来
的排队流程。

# Spring
两大特性：依赖注入、面向切面编程
## 依赖注入
### IoC是什么
Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是
一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容
器控制，而不是传统的在你的对象内部直接控制。  
* 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是
程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即
由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；
控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文
件等）。
* 有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直
接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依
赖对象；
![](./markdownFile/IOC图解.jpg)
### IoC能做什么
有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器
进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测
试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。
### DI
DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由
容器在运行期决定。  
依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用
的频率，并为系统搭建一个灵活、可扩展的平台。  
理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什
么”，那我们来深入分析一下： 
* 谁依赖于谁：当然是应用程序依赖于IoC容器；
* 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；
* 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖
的对象；
* 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资
源、常量数据）；    

IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述。
### 依赖注入能给我们带来哪些好
*  动态替换Bean依赖对象，程序更灵活：替换Bean依赖对象，无需修
改源文件：应用依赖注入后，由于可以采用配置文件方式实现，从而能
随时动态的替换Bean的依赖对象，无需修改java源文件；
* 更好实践面向接口编程，代码更清晰：在Bean中只需指定依赖对象的
接口，接口定义依赖对象完成的功能，通过容器注入依赖实现；
* 更好实践优先使用对象组合，而不是类继承：因为IoC容器采用注入
依赖，也就是组合对象，从而更好的实践对象组合。
* 增加Bean可复用性：依赖于对象组合，Bean更可复用且复用更简单；
* 降低Bean之间耦合：由于我们完全采用面向接口编程，在代码中没有
直接引用Bean依赖实现，全部引用接口，而且不会出现显示的创建依赖
对象代码，而且这些依赖是由容器来注入，很容易替换依赖实现类，从
而降低Bean与依赖之间耦合；
* 代码结构更清晰：要应用依赖注入，代码结构要按照规约方式进行书
写，从而更好的应用一些最佳实践，因此代码结构更清晰。
### Spring IoC容器注入依赖资源主要有以下两种基本实现方式：
构造器注入：就是容器实例化Bean时注入那些依赖，通过在在Bean定义
中指定构造器参数进行注入依赖，包括实例工厂方法参数注入依赖，但
静态工厂方法参数不允许注入依赖；  
setter注入：通过setter方法进行注入依赖；
### 什么是循环依赖
 循环依赖就是循环引用，就是两个或多个Bean相互之间的持有对方，比
 如CircleA引用CircleB，CircleB引用CircleC，CircleC引用CircleA，
 则它们最终反映为一个环。  
###  Spring如何解决循环依赖
构造器循环依赖：表示通过构造器注入构成的循环依赖，此依赖是无法
解决的，只能抛出BeanCurrentlyInCreationException异常表示循环
依赖。  
对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注
入但未完成其他步骤（如setter注入）的Bean来完成的，而且只能解决
单例作用域的Bean循环依赖。  
 具体步骤如下：  
1、Spring容器创建单例“circleA” Bean，首先根据无参构造器创建
Bean，并暴露一个“ObjectFactory ”用于返回一个提前暴露一个创
建中的Bean，并将“circleA” 标识符放到“当前创建Bean池”；然
后进行setter注入“circleB”；  
2、Spring容器创建单例“circleB” Bean，首先根据无参构造器创建
Bean，并暴露一个“ObjectFactory”用于返回一个提前暴露一个创建
中的Bean，并将“circleB” 标识符放到“当前创建Bean池”，然后进
行setter注入“circleC”；  
3、Spring容器创建单例“circleC” Bean，首先根据无参构造器创建
Bean，并暴露一个“ObjectFactory ”用于返回一个提前暴露一个创建
中的Bean，并将“circleC” 标识符放到“当前创建Bean池”，然后进
行setter注入“circleA”；进行注入“circleA”时由于提前暴露
了“ObjectFactory”工厂从而使用它返回提前暴露一个创建中
的Bean；  
4、最后在依赖注入“circleB”和“circleA”，完成setter注入。  
对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因
为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法
提前暴露一个创建中的Bean。  
### Spring Bean
Spring Bean是被Spring 容器实例，组装的及管理的Java对象。
#### Spring中Bean的Scope作用域
Spring提供“singleton”和“prototype”两种基本作用域，另外提
供“request”、“session”、“global session”三种web作用
域；Spring还允许用户定制自己的作用域。
#### Spring 三种配置方案
 1.在XML中进行显示配置  
 2.使用Java代码进行显示配置  
 3.隐式的bean发现机制和自动装配  
### Bean的生命周期
* 实例化bean对象(通过构造方法或者工厂方法)
* 设置对象属性(setter等)（依赖注入）
* 如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()
方法传递Bean的ID。（和下面的一条均属于检查Aware接口）
* 如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()
方法传入工厂自身
* 将Bean实例传递给Bean的前置处理器
的postProcessBeforeInitialization(Object bean, String beanname)
方法
* 调用Bean的初始化方法
* 将Bean实例传递给Bean的后置处理器的
postProcessAfterInitialization(Object bean, String beanname)
方法
* 使用Bean
* 容器关闭之前，调用Bean的销毁方法
### IOC容器的初始化分为三个过程实现：
* 第一个过程是Resource资源定位。这个Resouce指的是BeanDefinition
的资源定位。这个过程就是容器找数据的过程，就像水桶装水需要先
找到水一样。
* 第二个过程是BeanDefinition的载入过程。这个载入过程是把用户定
义好的Bean表示成Ioc容器内部的数据结构，而这个容器内部的数据结
构就是BeanDefition。
* 第三个过程是向IOC容器注册这些BeanDefinition的过程，这个过程就
是将前面的BeanDefition保存到HashMap中的过程。
### Spring框架中的单例Beans是线程安全的么
有状态bean不安全；  
解决方法：  
改为原型模式；  
使用ThreadLocal;
改为无状态；

## AOP
Aspect Oriented Programming（AOP）；面向切面编程；
### 应用场景
日志记录，性能统计，安全控制，事务处理，异常处理等等；
### 五种通知：
前置；后置；返回；异常；环绕；
### 4种类型的AOP支持：
基于代理的SpringAOP；  
纯POJO切面；  
@AspectJ注入的切面；  
注入式AspectJ切面；
### 动态代理
JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在
调用具体方法前调用InvokeHandler来处理。  
CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开
源包，将代理对象类的class文件加载进来，通过修改其字节码生成子
类来处理。  

区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代
理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类
的实现方式，不能代理final修饰的类。  

## 事务
事务有四个特性：ACID  
原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。
事务的原子性确保动作要么全部完成，要么完全不起作用。  
一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必
须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。
在现实中的数据不应该被破坏。  
隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每
个事务都应该与其他事务隔离开来，防止数据损坏。  
持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结
果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况
下，事务的结果被写到持久化存储器中。  
Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管
理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架
的事务来实现。  
### 事务属性包含了5个方面
![](./markdownFile/事务属性.png)
### 传播行为
当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。  
Spring定义了七种传播行为：
* PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事
务存在，方法将会在该事务中运行。否则，会启动一个新的事务  
* PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存
在当前事务的话，那么该方法会在这个事务中运行
* PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务
不存在，则会抛出一个异常
* PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务
中。一个新的事务将被启动。如果存在当前事务，在该方法执行期
间，当前事务会被挂起。两个独立的事务，互不相干。
* PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如
果存在当前事务，在该方法运行期间，当前事务将被挂起。
* PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果
当前正有一个事务在运行，则会抛出异常
* PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法
将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地
提交或回滚。如果当前事务不存在，那么其行为
与PROPAGATION_REQUIRED一样。嵌套事务一个非常重要的概念就是内层
事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而
内层事务操作失败并不会引起外层事务的回滚。

### 隔离级别
隔离级别定义了一个事务可能受其他并发事务影响的程度。   
并发事务引起的问题 ：  
* 脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写
但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获
取的数据就是无效的。
* 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务
执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通
常是因为另一个并发事务在两次查询期间进行了更新。
* 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事
务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数
据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不
存在的记录。
五种隔离级别：
* ISOLATION_DEFAULT	使用后端数据库默认的隔离级别
* ISOLATION_READ_UNCOMMITTED	最低的隔离级别，允许读取尚未提
交的数据变更，可能会导致脏读、幻读或不可重复读
* ISOLATION_READ_COMMITTED	允许读取并发事务已经提交的数据，可
以阻止脏读，但是幻读或不可重复读仍有可能发生
* ISOLATION_REPEATABLE_READ	对同一字段的多次读取结果都是一致
的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但
幻读仍有可能发生
* ISOLATION_SERIALIZABLE	最高的隔离级别，完全服从ACID的隔离级
别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，
因为它通常是通过完全锁定事务相关的数据库表来实现的
## Spring事务
Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户
在代码中精确定义事务的边界，而声明式事务（基于AOP）有助于用户
将操作与事务规则进行解耦。    
简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的
事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作
用，又可以不影响业务代码的具体实现。  
## 声明式事务
五种Spring事务的配置方式，配置文件如下：
* 每个Bean都有一个代理
* 所有Bean共享一个代理基类
* 使用拦截器
* 使用tx标签配置的拦截器
* 全注解

# springmvc请求流程
1 首先用户发送请求到前端控制器DispatcherServlet，也是springmvc的
核心控制器，前端控制器收到请求后自己 不进行处理，而是委托给其他
的解析器进行处理，作为统一访问点，进行全局的流程控制；  
2 DispatcherServlet调用HandlerMapping，HandlerMapping将会把请
求映射为HandlerExecutionChain对象（包 含一个Handler处理器对象，
也就是Controller层，多个 HandlerInterceptor拦截器）返回给
DispatcherServlet；  
3 DispatcherServlet根据得到的Handler，调用合适的HandlerAdapter，
HandlerAdapter将会把处理器 （Handler） 包装为适配器，
从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易
支持很多类型的处理器。  
4 HandlerAdapter会根据适配的结果调用真正的处理器(Handler)完成
请求处理，并向DispatcherServlet返回一个ModelAndView对象。  
5 根据返回的ModelAndView选择一个适合的ViewResolver（视图解析器）
返回给DispatcherServlet   
6 ViewResolver根据view 和 model 渲染视图   
7 将渲染结果返回给客户端。   


# JVM, JMM
## java虚拟机模型（以下简称jvm）；
jvm的内部结构如下图所示：  
![](./markdownFile/JVM结构.png)
*  Class Loader（类加载器）就是将Class文件加载到内存，再说的
详细一点就是，把描述类的数据从Class文件加载到内存，并对数据进
行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java
类型，这就是类加载器的作用。
* Run Data Area（运行时数据区） 就是我们常说的JVM管理的内存了;
所有写的程序都被加载到这里，之后才开始运行。
*  Execution engine（执行引擎） 是Java虚拟机最核心的组成部分之
一。执行引擎用于执行指令，不同的java虚拟机内部实现中，执行引擎
在执行Java代码的时候可能有解释执行（解释器执行）和编译执行（通
过即时编译器产生本地代码执行，例如BEA JRockit），也有可能两者
兼备。任何JVM specification实现(JDK)的核心都
是Execution engine，不同的JDK例如Sun 的JDK 和IBM的JDK好坏主要
就取决于他们各自实现的Execution engine的好坏。
* Native interface 与native libraries交互，是其它编程语言交互
的接口。当调用native方法的时候，就进入了一个全新的并且不再受
虚拟机限制的世界，所以也很容易出现JVM无法控制
的native heap OutOfMemory。
### Run Data Area（运行时数据区）
* Program Counter Register(程序计数器)；线程私有、指向下一条要
执行的字节码指令；
* Java Stack（Java虚拟机栈），线程私有，生命周期与线程相同。描
述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建
一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、
方法出口；局部变量表存放了编译期可知的各种基本数据类型，对象引用
，returnAdress；
* Native Method Stack（本地方法栈）为虚拟机使用到的Native 方法
服务；
* Heap	线程共享，由于现在收集器基本采用的分代收集算法，所
以Java堆中还可以细分：新生代和老生代；更细致一点的有Eden空间
、From Survivor空间、To Survivor空间等。所有的对象实例以及数
组都要在堆上分配，是垃圾收集器管理的主要区域；
* Method Area（方法区），别名叫做非堆(Non-Heap)，线程共享的内
存区域。存储已被虚拟机加载的类信息、常量、静态变量、即时编译器
编译后的代码。
#### 运行时常量池 
存放编译期生成的各种字面量和符号引用；
## JMM
从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程
之间的共享变量存储在主内存（Main Memory）中，每个线程都有一
个私有的本地内存（Local Memory），本地内存中存储了该线程以
读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实
存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器
优化。
![](./markdownFile/JMM.png)
### 从Java内存模型理解synchronized、volatile和final关键字
* volatile 定义的变量，特殊性在于：  
一个线程对 volatile 变量的写一定对之后对这个变量的读的线程可见。
* synchronized 使得它作用范围内的代码对于不同线程是互斥的，并
且线程在释放锁的时候会将共享变量的值刷新到主内存中。
* final变量的特殊之处在于：final 变量一经初始化，就不能改变其值。
这里的值对于一个对象或者数组来说指的是这个对象或者数组的引用
地址。
### 引用逃逸

# Java中的数据类型在内存的存储原理
* 基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值
就是存储在栈空间里面，Java语言里面八种数据类型是这种存储模
型 （对于整型定义数值不在（-128~127）之间的话 定义时会在堆
中创建对象）；
* 引用类型的存储原理：“引用”(存储对象在内存堆上的地址)是存
储在有序（先进后出）的内存栈上的，而对象本身的值存储在内存堆
上的 ；

# java jdk1.7常量池移到哪去了？
java jdk1.7中的常量池确实是移到了堆中，同时在jdk1.8中移除整
个永久代，取而代之的是一个叫元空间（Metaspace）的区域。
# 元空间
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过
元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是
使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制
，但可以通过以下参数来指定元空间的大小：  
  -XX:MetaspaceSize 初始空间大小，达到该值就会触发垃圾收集
  进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间
  ，就适当降低该值；如果释放了很少的空间，那么在不
  超过MaxMetaspaceSize时，适当提高该值。  
  -XX:MaxMetaspaceSize最大空间，默认是没有限制的。  
# JVM怎样判断两个类是否相同
Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器
是否一样。
# 分析 Object obj = new Object(); 对象创建过程?
* 检查常量池中是否存在该类的符号引用，如果没有，则先加载该
类，并解析和初始化
* 为对象分配内存
* 内存分配完成后的必要设置
* 对象的初始化，执行init方法
# String s = new String("abc");创建了几个对象?
两个；
# 对象的访问定位
直接指针；  
句柄访问；

# 垃圾回收
## 判断对象已死
![](./markdownFile/对象已死分析算法.png)
* 引用计数法
缺点：对象之间相互引用问题；
* 可达性分析
GC Roots对象：
![](./markdownFile/GC%20Roots.png)

## 四种引用类型
强引用；软引用；弱引用；虚引用；
## 不可达对象两次标记过程：
第一次标记条件：是否执行finalize（）方法；未覆盖或已执行则不
标记；  
否则，讲对象放入F-Queue队列；由一个低优先级线程执行，不保证会
结束；
## 永久代垃圾回收
两类的内容：废弃常量、无用的类；
### 无用的类的条件
![](./markdownFile/无用的类.png)

## 垃圾回收算法
* 标记-清除算法  
缺点：1、效率低；2、产生大量不连续空间碎片；
* 复制算法  
目的：解决效率问题；  
缺点：内存空间浪费；  
新生代的垃圾回收算法；将内存划分为一块Eden、两块Survive空间；
比例8:1；每次使用Eden和其中一块Survive空间；回收时复制到另一
块Survive空间；  
* 标记-整理算法  
让所有对象向一端移动，清除边界以外内存；

## hotspot垃圾回收算法实现
### 安全点
对应 OopMap 的位置即可作为一个安全点（Safe Point）。
* 两种线程中断方式；

# 垃圾收集器
![](./markdownFile/垃圾回收器.png)
## CMS垃圾回收器
CMS是老年代垃圾收集器；在收集过程中可以与用户线程并发操作。它
可以与Serial收集器和Parallel New收集器搭配使用。CMS牺牲了系
统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。可
以通过JVM启动参数：-XX:+UseConcMarkSweepGC来开启CMS。  
以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实
现；  
过程：  
1、初始标记：独占CPU，仅标记GCroots能直接关联的对象  
2、并发标记：可以和用户线程并行执行，标记所有可达对象  
3、重新标记：独占CPU(STW)，对并发标记阶段用户线程运行产生的
垃圾对象进行标记修正  
4、并发清理：可以和用户线程并行执行，清理垃圾  
优点:  
并发，低停顿  
缺点：  
1、对CPU非常敏感：在并发阶段虽然不会导致用户线程停顿，但是
会因为占用了一部分线程使应用程序变慢  
2、无法处理浮动垃圾：在最后一步并发清理过程中，用户线程执行
也会产生垃圾，但是这部分垃圾是在标记之后，所以只有等到下一
次gc的时候清理掉，这部分垃圾叫浮动垃圾  
3、CMS使用“标记-清理”法会产生大量的空间碎片，当碎片过多，将
会给大对象空间的分配带来很大的麻烦，往往会出现老年代还有很
大的空间但无法找到足够大的连续空间来分配当前对象，不得不提
前触发一次FullGC，为了解决这个问题CMS提供了一个开关参数，用
于在CMS顶不住，要进行FullGC时开启内存碎片的合并整理过程，但
是内存整理的过程是无法并发的，空间碎片没有了但是停顿时间变
长了  
CMS 出现FullGC的原因：   
1、年轻带晋升到老年带没有足够的连续空间，很有可能是内存碎
片导致的   
2、在并发过程中JVM觉得在并发过程结束之前堆就会满，需要提前
触发FullGC   
## G1
一款面向服务端应用的垃圾收集器;  
特点：  
1、并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用
多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分
其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以
通过并发的方式让java程序继续执行。  
2、分代收集：虽然G1可以不需要其他收集器配合就能独立管理整
个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处
理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获
取更好的收集效果。  
3、空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是
基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”
算法实现的。  
4、可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间
是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可
预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间
片段内，  
G1运作步骤：  
1、初始标记(stop the world事件 CPU停顿只处理垃圾)；  
2、并发标记(与用户线程并发执行)；  
3、最终标记(stop the world事件 ,CPU停顿处理垃圾)；  
4、筛选回收(stop the world事件 根据用户期望的GC停顿时间回收)
(注意：CMS 在这一步不需要stop the world)  

## java内存分配策略
* 对象优先在Eden分配  
当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
* 大对象直接进入老年代  
最典型的大对象就是那种很长的字符串以及数组。  
虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个
设置值的对象直接在老年代分配。  
* 长期存活的对象将进入老年代  
虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象
在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容
纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象
在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁。当它
的年龄增加到一定程度（默认是15岁），将会被晋升到老年代。对
象晋升到老年代的阈值可以通过参数-XX:MaxTenuringThreshold设
置。
* 空间分配担保
在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是
否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC是
确保安全的。如果不成立，则虚拟机会查看HandlePromotionFailure
设置值是否允许担保失败。如果允许，那么会继续检查老年代最大
可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果
大于，蒋尝试进行一次Minor GC，尽管这次GC是有风险的。如果
小于，或者HandlePromotionFailure设置不允许冒险，那这时也
要改为进行一次Full GC。 
* 动态对象年龄判定  

# Java中的内存泄露
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面
两个特点，首先，这些对象是可达的，即在有向图中，存在通路可
以与其相连；其次，这些对象是无用的，即程序以后不会再使用这
些对象。如果对象满足这两个条件，这些对象就可以判定为Java中
的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。  
Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周
期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再
需要，但是因为长生命周期持有它的引用而导致不能被回收，这就
是Java中内存泄漏的发生场景。具体主要有如下几大类：  
1、静态集合类引起内存泄漏：  
2、当集合里面的对象属性被修改后，再调用remove()方法时
不起作用。  
3、监听器  
4、各种连接  
5、内部类和外部模块的引用  
6、单例模式  

# 计算机网络
## URI URL
URI标记了一个网络资源；  
URL标记了一个互联网资源的访问地址。
URI是Uniform Resource Identifier（统一资源标识符）,表示是一个资源；
URL是Uniform Resource Locator（统一资源定位符），表示是一个地址； 
## URI格式
![](./markdownFile/绝对URI格式.png)
## HTTP请求/响应报文结构
一个HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。
![](./markdownFile/HTTP请求报文格式.png)
![](./markdownFile/HTTP请求报文.jpg)
HTTP响应报文也由四部分组成：响应行、响应头、空行、响应体
![](./markdownFile/HTTP响应报文格式.jpg)
## Cookie、Session、Token
* cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的
一种数据，仅仅是浏览器实现的一种数据存储功能。  
cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到
某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给
服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确
保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域
的cookie数量是有限的。
* session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为
了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后
客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就
知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以
有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。  
服务器使用session把用户的信息临时保存在了服务器上，用户离开网站
后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可
是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作
请求到了另一台服务器的时候session会丢失。
* Token几点特性：  
1.无状态、可扩展  
2.支持移动设备  
3.跨程序调用  
4.安全  
基于服务器验证方式暴露的一些问题：  
1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储
信息。当越来越多的用户发请求时，内存的开销也会不断增加。  
2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的
是可扩展性问题。  
3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨
域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资
源，就可以会出现禁止请求的情况。  
4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请
求伪造的攻击，并且能够被利用其访问其他的网站。  
基于Token的身份验证的过程如下:  
1.用户通过用户名和密码发送请求。  
2.程序验证。  
3.程序返回一个签名的token 给客户端。  
4.客户端储存token,并且每次用于每次发送请求。  
5.服务端验证token并返回数据。  
每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请
求无状态。我们同样通过设置服务器属
性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的
请求。需要注意的是，在ACAO头部标明(designating)*时，不得带
有像HTTP认证，客户端SSL证书和cookies的证书。
## HTTP隧道
隧道（tunnel） 是建立起来之后， 就会在两条连接之间对原始数据进
行盲转发的HTTP 应用程序。 HTTP 隧道通常用来在一条或多条 HTTP 连
接上转发非 HTTP 数据， 转发时不会窥探数据。HTTP 隧道的一种常见
用途是通过 HTTP 连接承载加密的安全套接字
层（SSL，Secure Sockets Layer） 流量， 这样 SSL 流量就可以穿过
只允许 Web 流量通过的防火墙了。  HTTP/SSL 隧道收到
一条 HTTP 请求， 要求建立一条到目的地址和端口的输
出连接， 然后在 HTTP 信道上通过隧道传输加密的 SSL 流量， 这样
就可以将其盲转发到目的服务器上去了.
## URL编码、解码
根据网络标准RFC 1738做了硬性规定：  
只有字母和数字[0-9a-zA-Z]、一些特殊符
号"$-_.+!*'(),"[不包括双引号]、以及某些保留字，才可以不经过编
码直接用于URL。  
因为RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）
自己决定，所以导致“URL编码”领域非常混乱。  
不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的
编码结果，为了保证客户端只用一种编码方法向服务器发出请求，可以使
用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插
手的机会。  
编码方法有三种：  
escape(url)、encodeURL(url)、encodeURLComponent(url) （url为需
要编码的URL）  
## get和post一般的区别：  
1.post更安全（不会作为url的一部分，不会被缓存、保存在服务器日
志、以及浏览器浏览记录中）  
2.post发送的数据量更大（get有url长度限制）  
3.post能发送更多的数据类型（get只能发送ASCII字符）  
4.post比get慢
## get比post更快
1.post不能进行管道化传输  
2.get会将数据缓存起来，而post不会  
3.最重要的一条，post在真正接受数据之前会先将请求头发送给服务器
进行确认，然后才真正发送数据  
4.post请求包含更多的请求头  
## HTTP长连接
 HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有
 翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不
 四次握手），等待在同域名下继续用这个通道传输数据；相反的就
 是短连接。  
HTTP 流水线技术；在一个TCP连接内，多个HTTP请求可以并行，下一个HTTP
请求在上一个HTTP请求的应答完成之前就发起；使用这个技术的还必须是幂等
的HTTP方法；
## 影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。
延迟：  
浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器
对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能
会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。  
DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立
连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓
存结果来达到减少这个时间的目的。  
建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最
快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，
但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次
握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。  
## HTTP1.0和HTTP1.1的一些区别
* 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires
来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例
如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更
多可供选择的缓存头来控制缓存策略。
* 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例
如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来
了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它
允许只请求资源的某个部分，即返回码是206（Partial Content），这
样就方便了开发者自由的选择以便于充分利用带宽和连接。
* 误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如
409（Conflict）表示请求的资源与资源的当前状态发生冲突；
410（Gone）表示服务器上的某个资源被永久性的删除。
* Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因
此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机
技术的发展，在一台物理服务器上可以存在多个虚拟主机
（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的
请求消息和响应消息都应支持Host头域，且请求消息中如果没有
Host头域会报告一个错误（400 Bad Request）。
* 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水
线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响
应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开
启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请
求都要创建连接的缺点。
## HTTP2.0和HTTP1.X相比的新特性
* 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于
文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到
健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这
种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
* 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作
连接共享机制的。一个request对应一个id，这样一个连接上可以有多
个request，每个连接的request可以随机的混杂在一起，接收方可以根
据request的 id将request再归属到各自不同的服务端请求里面。
*  header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大
量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传
输的header大小，通讯双方各自cache一份header fields表，既避免
了重复header的传输，又减小了需要传输的大小。
*  服务端推送（server push），同SPDY一样，HTTP2.0也具
有server push功能。

## HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？
TTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要
建立一个连接；  
HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后
面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，
后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；  
HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，
不会影响到其它连接的正常执行；  
 ![](./markdownFile/HTTP-Pipeling.jpg)

# 服务器推送到底是什么？
服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户
端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等
操作，所以静态资源通过服务端推送的方式可以极大地提升速度。
![](./markdownFile/服务端推送.png)
#一次http的过程
 1.对www.baidu.com这个网址进行DNS域名解析，得到对应的IP地址  
 2.根据这个IP，找到对应的服务器，发起TCP的三次握手  
 3.建立TCP连接后发起HTTP请求  
 4.服务器响应HTTP请求，浏览器得到html代码  
 5.浏览器解析html代码，并请求html代码中的资源
 （如js、css图片等）（先得到html代码，才能去找这些资源）  
 6.浏览器对页面进行渲染呈现给用户  

# https的交互过程
* 客户端发起HTTPS请求  
比如在浏览器里输入https://blog.csdn.net/yjclsx，然后请求到server
的443端口。浏览器会把自身支持的一系列Cipher Suite（密钥算法套件，
简称Cipher）发送给服务端。
* 服务端返回
服务端接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接
断开，反之则会从中选出一种加密算法和HASH算法以证书的形式返回给客户
端，证书中还包含了公钥、颁证机构、网址、失效日期等等。  
注：采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以
向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访
问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就
是一对公钥和私钥，用于非对称加密。
* 客户端验证证书并响应  
客户端收到服务端响应后会做以下几件事：  
1.3.1 验证证书的合法性   
颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访
问的地址一致等。证书验证通过后，在浏览器的地址栏提示网站安全。  
1.3.2 生成随机密码  
如果证书验证通过，或者用户接受了不授信的证书，此时客户端会生成一串
随机数，用于后续进行对称加密，以后称之为密钥，然后用证书中的公钥加
密这个密钥。  
1.3.3 HASH握手信息  
用最开始约定好的HASH方式，把握手消息取HASH值，然后用密钥加密 “握
手消息+握手消息的HASH值(即签名)”  。在这里之所以要加上握手消息的
HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中
没有被篡改过。  
最后将之前生成的所有信息发送给服务端。 
*  服务端解析和验证  
服务端接收客户端发来的数据之后要做以下的操作：  
1.4.1 解析和验证
使用自己的私钥将客户端使用公钥加密的信息解密得到之前客户端生成的
密钥。然后使用密钥解密客户端发来的加密后的握手消息得到 “握手消息
+握手消息的HASH值(即签名)”  ，最后同样对握手信息进行HASH签名，比
对和客户端传来的HASH值是否一致，如果一致则HASH验证通过，即表明握
手消息在传输过程中没有被篡改过。  
1.4.2 返回  
同样使用密钥加密一段握手消息，发送给客户端。  
1.5 客户端解析和验证
客户端用密钥解密并计算握手消息的HASH，如果与服务端发来的HASH一
致，此时握手过程结束。  
1.6 后续通信
由于RSA等非对称加密算法的性能是非常低的，原因在于寻找大素数、大数
计算、数据分割需要耗费很多的CPU周期，所以一般的HTTPS连接只在第一次
握手时使用非对称加密，通过握手交换对称加密的密钥，之后所有的通信数
据将由之前客户端生成的密钥进行对称加密。  
因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法
解密数据的，以此保证了通信的安全。  

# DNS
DNS占用53号端口，同时使用TCP和UDP协议。  
DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。  
DNS区域传输的时候使用TCP协议：  
1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了
解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。
区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应
答的数据量要多得多。  
2.TCP是一种可靠连接，保证了数据的准确性。  
域名解析时使用UDP协议：  
客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP
传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理
论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多
DNS服务器进行配置的时候，仅支持UDP查询包。  
# RESTful
rest式的web服务是一种ROA(The Resource-Oriented Architecture)(面
向资源的架构).

# TCP协议
TCP协议全称: 传输控制协议, 顾名思义, 就是要对数据的传输进行一定的
控制.
![](./markdownFile/tcp报头.png)
## 那么什么是三次握手? 什么是四次挥手呢?
![](./markdownFile/tcp状态转换.png)
三次握手  
第一次:  
客户端 - - > 服务器 此时服务器知道了客户端要建立连接了  
第二次:  
客户端 < - - 服务器 此时客户端知道服务器收到连接请求了  
第三次:  
客户端 - - > 服务器 此时服务器知道客户端收到了自己的回应  
到这里, 就可以认为客户端与服务器已经建立了连接.  
刚开始, 客户端和服务器都处于 CLOSE 状态.  
此时, 客户端向服务器主动发出连接请求, 服务器被动接受连接请求.  
1, TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接
请求, 此时服务器就进入了 LISTEN（监听）状态  
2, TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求
报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 
seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）
状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要
消耗掉一个序号。  
3, TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认
报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个
序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状
态。这个报文也不能携带数据, 但是同样要消耗一个序号。  
4, TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文
的ACK=1，确认序号是 y+1，自己的序列号是 x+1.  
5, 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当
服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开
始通信了。 

四次挥手.  
数据传输完毕后，双方都可以释放连接.  
此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开
连接，服务器被动断开连接.  
1, 客户端进程发出连接释放报文，并且停止发送数据。  
释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的
数据的最后一个字节的序号加1），此时客户端进入FIN-WAIT-1（终止等
待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。  
2, 服务器收到连接释放报文，发出确认报文，ACK=1，确认序号为 u+1，并
且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）
状态。  
TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这
时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若
发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整
个CLOSE-WAIT状态持续的时间。  
3, 客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止
等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务
器发送的最终数据）  
4, 服务器将最后的数据发送完毕后，就向客户端发送连接释放报
文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又
发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入
了LAST-ACK（最后确认）状态，等待客户端的确认。  
5, 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认
序号为w+1，而自己的序列号是u+1，此时，客户端就进入了TIME-WAIT（
时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长
报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状
态。  
6, 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤
销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间
要比客户端早一些。  
 

## 为什么不用两次?
主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产
生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端
发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长
了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时
重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连
接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为
网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手
的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和
资源的费。  
如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端
接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出
确认。由于服务器收不到确认，就知道客户端并没有请求连接。  
## 为什么不用四次?
因为三次已经可以满足需要了, 四次就多余了.

## 为什么最后客户端还要等待 2*MSL的时间呢?
MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同
的MSL值。  
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这
个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文
请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它
没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时
间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时
器。  
第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文
段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL
时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中
消失。这样新的连接中不会出现旧连接的请求报文。  
## 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文
后，把ACK和SYN放在一个报文里发送给客户端。  
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数
据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以
己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对
方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从
而导致多了一次。
## 如果已经建立了连接, 但是客户端突发故障了怎么办?
TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直
等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复
位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的
任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一
次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故
障，接着就关闭连接。
























